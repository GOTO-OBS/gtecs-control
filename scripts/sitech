#!/usr/bin/env python

########################################################################
#                              sitech.py                               #
#           ~~~~~~~~~~~~~~~~~~~~~~~##~~~~~~~~~~~~~~~~~~~~~~~           #
#  G-TeCS script to provide control over the sitech interface daemon   #
#                      Martin Dyer, Sheffield, 2017                    #
#           ~~~~~~~~~~~~~~~~~~~~~~~##~~~~~~~~~~~~~~~~~~~~~~~           #
#                   Based on the SLODAR/pt5m system                    #
########################################################################

### Import ###
# Python modules
from __future__ import absolute_import
from __future__ import print_function
import os, sys
import readline
import time
import Pyro4
from six.moves import input
# TeCS modules
from gtecs.tecs_modules import misc
from gtecs.tecs_modules import params

########################################################################
# SiTech interface functions

def start_win_interface(interface):
    '''Start an interface on Windows (unless it is already running)'''
    process = params.WIN_INTERFACES[interface]['PROCESS']
    host    = params.WIN_INTERFACES[interface]['HOST']
    pyroid  = params.WIN_INTERFACES[interface]['PYROID']
    if params.REDIRECT_STDOUT:
        output = params.WIN_CONFIG_PATH + 'logs/' + pyroid + '-stdout.log'
    else:
        output = ''

    process_ID = misc.get_process_ID_windows(process, host, params.WIN_USER)
    if len(process_ID) == 0:
        # Run script
        cmd = ('ssh {}@{}'.format(params.WIN_USER, host)
              +" '{}".format(params.CYGWIN_PYTHON_PATH)
              +" {}scripts/{}".format(params.WIN_INSTALL_PATH, process)
              +" > {} 2>&1 &'".format(output))
        misc.getoutput(cmd)
        # See if it started
        process_ID_n = misc.get_process_ID_windows(process, host, params.WIN_USER)
        if len(process_ID_n) == 1:
            print('Interface started on {} (PID {})'.format(host, process_ID_n[0]))
        elif len(process_ID_n) > 1:
            print('ERROR: Multiple interfaces running on {} (PID {})'.format(host, process_ID_n))
        else:
            print('ERROR: Interface did not start on {}, check logs'.format(host))
    elif len(process_ID) == 1:
        print('ERROR: Interface already running on {} (PID {})'.format(host, process_ID[0]))
    else:
        print('ERROR: Multiple interfaces already running on {} (PID {})'.format(host, process_ID_n))


def ping_win_interface(interface):
    '''Ping an interface on Windows'''
    address = params.WIN_INTERFACES[interface]['ADDRESS']
    process = params.WIN_INTERFACES[interface]['PROCESS']
    host    = params.WIN_INTERFACES[interface]['HOST']

    process_ID = misc.get_process_ID_windows(process, host, params.WIN_USER)
    if len(process_ID) == 1:
        interface = Pyro4.Proxy(address)
        interface._pyroTimeout = params.PROXY_TIMEOUT
        try:
            ping = interface.ping()
            if ping == 'ping':
                print('Ping received OK, interface running on {} (PID {})'.format(host, process_ID[0]))
            else:
                print(ping + ', interface running on {} (PID {})'.format(host, process_ID[0]))
        except:
            print('ERROR: No response, interface running on {} (PID {})'.format(host, process_ID[0]))
    elif len(process_ID) == 0:
        print('ERROR: No response, interface not running on {}'.format(host))
    else:
        print('ERROR: Multiple interfaces running on {} (PID {})'.format(host, process_ID_n))


def shutdown_win_interface(interface):
    '''Shut an interface on Windows down nicely'''
    address = params.WIN_INTERFACES[interface]['ADDRESS']
    process = params.WIN_INTERFACES[interface]['PROCESS']
    host    = params.WIN_INTERFACES[interface]['HOST']

    process_ID = misc.get_process_ID_windows(process, host, params.WIN_USER)
    if len(process_ID) == 1:
        interface = Pyro4.Proxy(address)
        interface._pyroTimeout = params.PROXY_TIMEOUT
        try:
            interface.shutdown()
            # Have to request status again to close loop
            interface = Pyro4.Proxy(address)
            interface._pyroTimeout = params.PROXY_TIMEOUT
            interface.prod()
            interface._pyroRelease()

            # See if it shut down
            time.sleep(2)
            process_ID_n = misc.get_process_ID_windows(process, host, params.WIN_USER)
            if len(process_ID_n) == 0:
                print('Interface shut down on {}'.format(host))
            elif len(process_ID_n) == 1:
                print('ERROR: Interface still running on {} (PID {})'.format(host, process_ID_n[0]))
            else:
                print('ERROR: Multiple interfaces still running on {} (PID {})'.format(host, process_ID_n))
        except:
            print('ERROR: No response, interface still running on {} (PID {})'.format(host, process_ID[0]))
    elif len(process_ID) == 0:
        print('ERROR: No response, interface not running on {}'.format(host))
    else:
        print('ERROR: Multiple interfaces running on {} (PID {})'.format(host, process_ID_n))


def kill_win_interface(interface):
    '''Kill an interface on Windows (should be used as a last resort)'''
    process = params.WIN_INTERFACES[interface]['PROCESS']
    host    = params.WIN_INTERFACES[interface]['HOST']

    process_ID = misc.get_process_ID_windows(process, host, params.WIN_USER)
    if len(process_ID) >= 1:
        misc.kill_processes_windows(process, host, params.WIN_USER)

        # See if it is actually dead
        process_ID_n = misc.get_process_ID_windows(process, host, params.WIN_USER)
        if len(process_ID_n) == 0:
            print('Interface killed on {}'.format(host))
        elif len(process_ID_n) == 1:
            print('ERROR: Interface still running on {} (PID {})'.format(host, process_ID_n[0]))
        else:
            print('ERROR: Multiple interfaces still running on {} (PID {})'.format(host, process_ID_n))
    else:
        print('ERROR: Interface not running on {}'.format(host))


########################################################################
# Interactive functions

def interactive():
    while True:
        i_in = input('sitech> ').split()
        if len(i_in) > 0:
            command, *args = i_in
            if command == 'q' or command == 'exit':
                return
            else:
                query(command, args)

def query(command, args):
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Primary control functions
    if command == 'start':
        start_win_interface('sitech')
    elif command == 'shutdown':
        shutdown_win_interface('sitech')
    elif command == 'kill':
        kill_win_interface('sitech')
    elif command == 'ping':
        ping_win_interface('sitech')
    elif command == 'help' or command == '?':
        print_instructions()
    elif command == 'i':
        print(misc.ERROR('Already in interactive mode'))

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Unrecognized function
    else:
        print(misc.ERROR('Unrecognized command "%s"' %command))

########################################################################
# Output formatting functions

def print_instructions():
    help_str = misc.bold('Usage:') + ' sitech [command]' + '\n' +\
    ' ' + misc.undl('Interface commands') + ':' + '\n' +\
    '  sitech ' + misc.bold('start') + '             - start the interface' + '\n' +\
    '  sitech ' + misc.bold('shutdown') + '          - shutdown the interface' + '\n' +\
    '  sitech ' + misc.bold('kill') + '              - kill the interface (' + misc.rtxt('emergency use') + ')' + '\n' +\
    '  sitech ' + misc.bold('ping') + '              - ping the interface' + '\n' +\
    ' ' + misc.undl('Control commands') + ':' + '\n' +\
    '  sitech ' + misc.bold('i') + '                 - enter interactive mode' + '\n' +\
    '  sitech ' + misc.bold('q') + '/' + misc.bold('exit') + '            - quit interactive mode' + '\n' +\
    '  sitech ' + misc.bold('?') + '/' + misc.bold('help') + '            - print these instructions'
    print(help_str)

########################################################################

if len(sys.argv) == 1:
    print_instructions()
else:
    command, *args = sys.argv[1:]
    if command == 'i':
        interactive()
    else:
        query(command, args)
