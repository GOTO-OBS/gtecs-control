#!/usr/bin/env python3
"""Script to run in the morning to confirm the dome is closed."""

import argparse
import datetime
import os
import sys
import time
from collections import Counter

import astropy.units as u
from astropy.time import Time

from gtecs import logger
from gtecs import params
from gtecs.astronomy import night_startdate, observatory_location, sunalt_time
from gtecs.daemons import daemon_info
from gtecs.flags import Conditions, Status
from gtecs.misc import execute_command, get_pid, make_pid_file
from gtecs.observing import wait_for_dome
from gtecs.slack import send_slack_msg

import numpy as np

import obsdb as db


def send_dome_report(msg, confirmed_closed):
    """Send Slack message with webcams attached."""
    if confirmed_closed:
        colour = 'good'
    else:
        colour = 'danger'

    conditions = Conditions()
    conditions_summary = conditions.get_formatted_string(good=':heavy_check_mark:',
                                                         bad=':exclamation:')
    if conditions.bad:
        msg2 = 'Conditions are bad'
    else:
        msg2 = 'Conditions are good'
    attach_conds = {'fallback': 'Conditions summary',
                    'title': msg2,
                    'text': conditions_summary,
                    'color': colour,
                    'ts': conditions.current_time.unix,
                    }

    status = Status()
    attach_status = {'fallback': 'System mode: {}'.format(status.mode),
                     'text': 'System is in "*{}*" mode'.format(status.mode),
                     'color': colour,
                     }

    ts = '{:.0f}'.format(time.time())
    ext_url = 'http://lapalma-observatory.warwick.ac.uk/webcam/ext2/static?' + ts
    attach_ext = {'fallback': 'External webcam view',
                  'title': 'External webcam view',
                  'title_link': 'http://lapalma-observatory.warwick.ac.uk/eastcam/',
                  'text': 'Image attached:',
                  'image_url': ext_url,
                  'color': colour,
                  }
    int_url = 'http://lapalma-observatory.warwick.ac.uk/webcam/goto/static?' + ts
    attach_int = {'fallback': 'Internal webcam view',
                  'title': 'Internal webcam view',
                  'title_link': 'http://lapalma-observatory.warwick.ac.uk/goto/dome/',
                  'text': 'Image attached:',
                  'image_url': int_url,
                  'color': colour,
                  }

    attachments = [attach_conds, attach_status, attach_ext, attach_int]
    send_slack_msg(msg, attachments=attachments)


def get_lastnight_observations(date_string):
    """Get the tiles observed last night, and which survey they were part of."""
    # Get the dates for the start and end of the night just finished
    midday_yesterday = datetime.datetime.strptime(date_string + ' 12:00:00', '%Y-%m-%d %H:%M:%S')
    midday_today = midday_yesterday + datetime.timedelta(days=1)

    with db.open_session() as session:
        # Get the current grid from the database
        db_grid = db.get_current_grid(session)

        # Create a SkyGrid from the database Grid
        grid = db_grid.get_skygrid()

        # Use Astroplan to get all the tiles that would have been visible last night
        visible_tiles = grid.get_visible_tiles(observatory_location(),
                                               time_range=(Time(midday_yesterday),
                                                           Time(midday_today)),
                                               alt_limit=30,
                                               sun_limit=-12,
                                               )

        # Get all pointings observed last night on the grid
        query = session.query(db.Pointing).filter(
            db.Pointing.status == 'completed',
            db.Pointing.grid == db_grid,
            db.Pointing.stopped_time > midday_yesterday,
            db.Pointing.stopped_time < midday_today,
        )
        all_pointings = query.all()
        all_surveys = []
        all_tiles = []

        # Get the tile names of the all-sky survey pointings completed last night
        db_survey = db_grid.surveys[0]
        survey_pointings = [p for p in all_pointings if p.survey == db_survey]
        survey_tiles = [p.grid_tile.name for p in survey_pointings]
        all_surveys.append(db_survey.name)
        all_tiles.append(survey_tiles)

        # Get the names and surveys of the other pointings completed last night
        other_pointings = [p for p in all_pointings if p not in survey_pointings]
        other_tiles = np.array([p.grid_tile.name for p in other_pointings])
        other_surveys = np.array([p.survey.name if p.survey else 'None' for p in other_pointings])
        for survey in sorted(set(other_surveys)):
            all_surveys.append(survey)
            all_tiles.append(other_tiles[other_surveys == survey])

    return grid, visible_tiles, all_surveys, all_tiles


def get_survey_observations(date_string):
    """Get all survey observations prior to the given night."""
    # Get the dates for the start and end of the night just finished
    midday_yesterday = datetime.datetime.strptime(date_string + ' 12:00:00', '%Y-%m-%d %H:%M:%S')
    midday_today = midday_yesterday + datetime.timedelta(days=1)

    with db.open_session() as session:
        # Get the current survey from the database
        db_grid = db.get_current_grid(session)
        db_survey = db_grid.surveys[0]

        # Get all completed all-sky survey pointings since it started
        query = session.query(db.Pointing).filter(
            db.Pointing.status == 'completed',
            db.Pointing.survey == db_survey,
            db.Pointing.stopped_time < midday_today,
        )
        survey_pointings = query.all()

        # Count tiles
        counter = Counter([p.grid_tile.name for p in survey_pointings])
        count_dict = dict(counter)

        # Get start date of the survey
        startdate = min(p.stopped_time for p in survey_pointings)

    return count_dict, startdate


def run(test=False):
    """Run morning safety checks."""
    # Log output
    log = logger.get_logger('daymarshal', log_to_file=False, log_to_stdout=True, log_stdout=True)

    # Get the current night starting date and time of sunrise
    date = night_startdate()
    log.info('Started for night of {}'.format(date))
    sunrise = sunalt_time(date, 0 * u.deg, eve=False)

    # Wait until shortly after sunrise, so the pilot should be finished
    target = sunrise + 5 * u.min
    log.info('Waiting until {}'.format(target.datetime.strftime('%H:%M:%S')))
    while True and not test:
        if Time.now() > target:
            log.info('Passed target time')
            break
        time.sleep(2)

    # Check the dome status
    msg = ''
    confirmed_closed = False
    try:
        dome_info = daemon_info('dome')
        dome_status = dome_info['dome']
        if dome_status == 'closed':
            msg = 'Day marshal confirmed dome is closed'
            log.info('Dome confirmed closed')
            confirmed_closed = True
        else:
            # Uh-oh
            msg = ':warning: WARNING: Day marshal could not confirm dome is closed :warning:'
            log.warning('The dome is not closed!')
    except Exception:
        msg = ':warning: WARNING: Day marshal dome status check failed :warning:'
        log.error('Error checking the dome', exc_info=True)

    # Send the report to Slack
    send_dome_report(msg, confirmed_closed)

    # It's not closed...
    # Maybe something happened to the pilot or the dome daemon
    while not confirmed_closed:
        time.sleep(30)
        try:
            # Try sending the command
            log.warning('Sending dome close command')
            execute_command('dome restart')
            time.sleep(5)
            execute_command('dome close')

            # Wait for the dome to (hopefully) close
            wait_for_dome(target_position='closed', timeout=120)

            # Check again
            dome_info = daemon_info('dome')
            dome_status = dome_info['dome']
            if dome_status == 'closed':
                msg = 'Day marshal has closed the dome'
                log.info('Dome confirmed closed')
                confirmed_closed = True
            else:
                # UH-OH
                msg = ':warning: CRITICAL: Day marshal could not close the dome! :warning:'
                log.warning('The dome is still not closed!')

        except Exception:
            log.error('Error sending dome command', exc_info=True)
            msg = ':warning: CRITICAL: Day marshal could not close the dome! :warning:'

        # Send the report to Slack again
        send_dome_report(msg, confirmed_closed)

    # Update IRES tables on all control machines
    hosts = np.unique([params.DAEMONS[daemon]['HOST'] for daemon in params.DAEMONS])
    for host in hosts:
        log.info('Updating IERS tables on {}'.format(host))
        # Run the command through Python, so we can do it on the remote machines
        command = '{} -m gtecs.observing_scripts.update_IERS'.format(sys.executable)
        if host == params.LOCAL_HOST:
            execute_command(command, timeout=120)
        else:
            execute_command("ssh {} '{}'".format(host, command), timeout=120)

    # Restart the RoomAlert
    log.info('Rebooting RoomAlert')
    execute_command('power off poe')
    time.sleep(5)
    execute_command('power on poe')

    #####

    # Plots for Slack
    plot_direc = os.path.join(params.FILE_PATH, 'plots')
    if not os.path.exists(plot_direc):
        os.mkdir(plot_direc)

    # Get last night's observations
    grid, visible_tiles, surveys, tiles = get_lastnight_observations(date)
    notvisible_tiles = [tile for tile in grid.tilenames if tile not in visible_tiles]
    obs_tiles = sum(len(t) for t in tiles)
    obs_survey = len(tiles[0])
    log.info('Last night we observed {} tiles'.format(obs_tiles))
    log.info('Last night we observed {} all-sky survey tiles'.format(obs_survey))

    # Remove the empty all-sky survey list if we didn't observe any
    if obs_survey == 0:
        surveys = surveys[1:]
        tiles = tiles[1:]

    # Make a plot of last night's observations (assuming we observed anything)
    if obs_tiles > 0:
        title = 'GOTO observations for\nnight beginning {}'.format(date)
        filepath = os.path.join(plot_direc, '{}_observed.png'.format(date))
        grid.plot(filename=filepath,
                  color={tilename: '0.5' for tilename in notvisible_tiles},
                  highlight=tiles,
                  highlight_label=surveys,
                  alpha=0.5,
                  title=title)

        # Send message to Slack with the plot attached
        log.info('Sending coverage plot to Slack')
        send_slack_msg('Last night coverage plot', filepath=filepath)

    # Create plot of all-sky survey coverage (assuming we observed any new ones)
    if obs_survey > 0:
        # Get all survey observations (and the date it started)
        count_dict, startdate = get_survey_observations(date)

        # Create plot
        title = 'GOTO all-sky survey coverage\n'
        title += 'from {} to {}'.format(startdate.strftime('%Y-%m-%d'), date)
        filepath = os.path.join(plot_direc, '{}_survey.png'.format(date))
        grid.plot(filename=filepath,
                  color=count_dict,
                  discrete_colorbar=True,
                  highlight=tiles[0],
                  highlight_color='red',
                  highlight_label='observed last night',
                  alpha=0.5,
                  title=title)

        # Send message to Slack with the plot attached
        log.info('Sending coverage plot to Slack')
        send_slack_msg('All-sky survey coverage plot', filepath=filepath)

    log.info('Done')


if __name__ == '__main__':
    # Disable day marshal in engineering mode
    status = Status()
    if status.mode == 'engineering':
        print('Day marshal is disabled in engineering mode')
        send_slack_msg('Day marshal tried to run, but system is in engineering mode')
        sys.exit(0)

    # Check it it's already running
    pid = get_pid('daymarshal')
    if pid:
        print('Day marshal is already running (PID {})'.format(pid))
        send_slack_msg('Day marshal tried to run, but is already running')
        sys.exit(0)

    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-t', '--test', action='store_true', default=False)
    args = parser.parse_args()

    with make_pid_file('daymarshal'):
        run(args.test)
