#!/usr/bin/env python3
"""A script to provide control over the foc daemon."""

import os
import sys

from gtecs import daemons
from gtecs import errors
from gtecs import misc
from gtecs import params


DAEMON_ID = os.path.basename(__file__)


def query(command, args, daemon_id):
    """Process a query."""
    # Command functions
    if command in ['help', '?']:
        print_instructions()

    elif command == 'i':
        raise errors.InputError('Already in interactive mode')

    # Primary daemon control
    elif command == 'start':
        reply = daemons.start_daemon(daemon_id)
        print(reply)

    elif command == 'shutdown':
        reply = daemons.shutdown_daemon(daemon_id)
        print(reply)

    elif command == 'restart':
        reply = daemons.restart_daemon(daemon_id)
        print(reply)

    elif command == 'kill':
        reply = daemons.kill_daemon(daemon_id)
        print(reply)

    elif command in ['check', 'ping']:
        reply = daemons.check_daemon(daemon_id)
        print(reply)

    elif command in ['info', 'status']:
        # parse arguments
        if len(args) == 0:
            info_type = 'simple'
            force = False
        elif len(args) == 1 and args[0] in ['f', 'F', '-f', '-F', '--force-update']:
            info_type = 'simple'
            force = True
        elif len(args) == 1 and args[0] in ['v', 'V', '-v', '-V', '--verbose']:
            info_type = 'verbose'
            force = False
        elif len(args) == 1 and args[0] in ['r', 'R', '-r', '-R', '--raw']:
            info_type = 'raw'
            force = False
        elif (len(args) == 2 and
              ((args[0] in ['v', 'V', '-v', '-V', '--verbose'] and
                args[1] in ['f', 'F', '-f', '-F', '--force-update']) or
               (args[1] in ['v', 'V', '-v', '-V', '--verbose'] and
                args[0] in ['f', 'F', '-f', '-F', '--force-update']))):
            info_type = 'verbose'
            force = True
        elif (len(args) == 2 and
              ((args[0] in ['r', 'R', '-r', '-R', '--raw'] and
                args[1] in ['f', 'F', '-f', '-F', '--force-update']) or
               (args[1] in ['r', 'R', '-r', '-R', '--raw'] and
                args[0] in ['f', 'F', '-f', '-F', '--force-update']))):
            info_type = 'raw'
            force = True
        else:
            raise errors.InputError('Invalid arguments')
        # send command
        reply = daemons.daemon_function(daemon_id, 'get_info', args=[force])
        # print response
        if not reply:
            raise ValueError('No info returned, check daemon')
        elif info_type == 'simple':
            print_info_s(reply)
        elif info_type == 'verbose':
            print_info(reply)
        elif info_type == 'raw':
            print(reply)

    elif command in ['log', 'tail']:
        # parse arguments
        if 'stdout' in args:
            log_file = daemon_id + '-stdout.log'
            args.remove('stdout')
        else:
            log_file = daemon_id + '.log'
        log_path = os.path.join(params.LOG_PATH, log_file)
        tail_command = 'tail {} {}'.format(log_path, ' '.join(args))
        # send command
        misc.execute_long_command(tail_command)

    # Daemon functions
    elif command == 'set':
        # parse arguments
        if len(args) == 1 and misc.is_num(args[0]):
            # foc set <pos>
            pos = int(args[0])
            pos_dict = {ut: pos for ut in params.UTS_WITH_FOCUSERS}
        elif len(args) == 2 and misc.is_num(args[1]):
            # foc set <ut>[,<ut>...] <pos>
            ut_list = [int(x) for x in args[0].split(',')]
            pos = int(args[1])
            pos_dict = {ut: pos for ut in ut_list}
        elif len(args) == 2 and len(args[0].split(',')) == len(args[1].split(',')):
            # foc set <ut>[,<ut>...] <pos>[,<pos>...]
            ut_list = [int(x) for x in args[0].split(',')]
            pos_list = [int(x) for x in args[1].split(',')]
            pos_dict = {ut: pos for ut, pos in zip(ut_list, pos_list)}
        else:
            raise errors.InputError('Invalid arguments')
        # send command
        reply = daemons.daemon_function(daemon_id, 'set_focusers', [pos_dict])
        print(reply)

    elif command == 'move':
        # parse arguments
        if len(args) == 1 and misc.is_num(args[0]):
            # foc move <steps>
            steps = int(args[0])
            steps_dict = {ut: steps for ut in params.UTS_WITH_FOCUSERS}
        elif len(args) == 2 and misc.is_num(args[1]):
            # foc move <ut>[,<ut>...] <steps>
            ut_list = [int(x) for x in args[0].split(',')]
            steps = int(args[1])
            steps_dict = {ut: steps for ut in ut_list}
        elif len(args) == 2 and len(args[0].split(',')) == len(args[1].split(',')):
            # foc move <ut>[,<ut>...] <steps>[,<steps>...]
            ut_list = [int(x) for x in args[0].split(',')]
            steps_list = [int(x) for x in args[1].split(',')]
            steps_dict = {ut: steps for ut, steps in zip(ut_list, steps_list)}
        else:
            raise errors.InputError('Invalid arguments')
        # send command
        reply = daemons.daemon_function(daemon_id, 'move_focusers', [steps_dict])
        print(reply)

    elif command == 'home':
        # parse arguments
        if len(args) == 0:
            # foc home
            ut_list = params.UTS_WITH_FOCUSERS
        elif len(args) == 1:
            # foc home <ut>[,<ut>...]
            ut_list = [int(x) for x in args[0].split(',')]
        else:
            raise errors.InputError('Invalid arguments')
        # send command
        reply = daemons.daemon_function(daemon_id, 'home_focusers', [ut_list])
        print(reply)

    elif command in ['stop', 'halt', 'abort']:
        # parse arguments
        if len(args) == 0:
            # foc stop
            ut_list = params.UTS_WITH_FOCUSERS
        elif len(args) == 1:
            # foc stop <ut>[,<ut>...]
            ut_list = [int(x) for x in args[0].split(',')]
        else:
            raise errors.InputError('Invalid arguments')
        # send command
        reply = daemons.daemon_function(daemon_id, 'stop_focusers', [ut_list])
        print(reply)

    elif command == 'sync':
        # parse arguments
        if len(args) == 1 and misc.is_num(args[0]):
            # foc sync <position>
            position = int(args[0])
            position_dict = {ut: position for ut in params.UTS_WITH_FOCUSERS}
        elif len(args) == 2 and misc.is_num(args[1]):
            # foc sync <ut>[,<ut>...] <position>
            ut_list = [int(x) for x in args[0].split(',')]
            position = int(args[1])
            position_dict = {ut: position for ut in ut_list}
        elif len(args) == 2 and len(args[0].split(',')) == len(args[1].split(',')):
            # foc sync <ut>[,<ut>...] <position>[,<position>...]
            ut_list = [int(x) for x in args[0].split(',')]
            position_list = [int(x) for x in args[1].split(',')]
            position_dict = {ut: position for ut, position in zip(ut_list, position_list)}
        else:
            raise errors.InputError('Invalid arguments')
        # send command
        reply = daemons.daemon_function(daemon_id, 'sync_focusers', [position_dict])
        print(reply)

    # Unrecognized function
    else:
        raise errors.InputError('Unrecognized command "{}"'.format(command))


def print_info(info):
    """Print the full info dict."""
    print('###### FOCUSER INFO #######')
    for ut in params.UTS_WITH_FOCUSERS:
        print('FOCUSER {} ({})'.format(ut, params.UT_DICT[ut]['INTERFACE']))
        print('Status: {}'.format(info[ut]['status']), end='')
        if info[ut]['remaining'] > 0:
            print(' ({})'.format(info[ut]['remaining']))
        else:
            print('')
        print('Current motor pos:    {}'.format(info[ut]['current_pos']))
        print('Maximum motor limit:  {}'.format(info[ut]['limit']))
        print('Internal temperature: {}'.format(info[ut]['int_temp']))
        print('External temperature: {}'.format(info[ut]['ext_temp']))
        print('Serial number:        {}'.format(info[ut]['serial_number']))
        print('Hardware class:       {}'.format(info[ut]['hw_class']))
        print('~~~~~~~')
    print('Uptime: {:.1f}s'.format(info['uptime']))
    print('Timestamp: {}'.format(info['timestamp']))
    print('###########################')


def print_info_s(info):
    """Print the info dict in a compact way."""
    l = max(len(str(info[ut]['limit'])) for ut in params.UTS_WITH_FOCUSERS)
    for ut in params.UTS_WITH_FOCUSERS:
        print('FOCUSER {} ({})'.format(ut, params.UT_DICT[ut]['INTERFACE']), end=' ')
        if info[ut]['status'] != 'Moving':
            cur_pos = '{:>{}d}'.format(info[ut]['current_pos'], l)
            limit = '{:<{}d}'.format(info[ut]['limit'], l)
            print('  Current position: {}/{}'.format(cur_pos, limit), end=' ')
            print('  [{}]'.format(info[ut]['status']))
        else:
            print('  Moving', end='')
            if info[ut]['remaining'] > 0:
                print(' ({})'.format(info[ut]['remaining']))
            else:
                print('')


def print_instructions():
    """Print instructions for using the daemon."""
    print('Usage: foc command [options]',
          'Daemon commands:',
          '  start                          start the daemon',
          '  shutdown                       shutdown the daemon',
          '  restart                        restart the daemon',
          '  kill                           kill the daemon',
          '  check/ping                     check the daemon for errors',
          'Focuser commands:',
          '  move [uts] steps               move by the given steps',
          '  set [uts] pos                  move to the given position',
          '  home [uts]                     move to the home position',
          '  stop/halt/abort [uts]          stop the focusers moving',
          '  sync [uts] pos                 set the current focuser position to the given value',
          '  info/status [-r|-v] [-f]       report current status [raw/verbose/force-update]',
          '  log [stdout]                   print daemon log (tail alias)',
          'Control commands:',
          '  i                              enter interactive mode',
          '  q/exit                         quit interactive mode',
          '  ?/help                         print these instructions',
          sep='\n')


if __name__ == '__main__':
    if len(sys.argv) == 1:
        print_instructions()
    else:
        command, *args = sys.argv[1:]
        if command == 'i':
            while True:
                interactive_input = input('{}> '.format(DAEMON_ID)).split()
                if len(interactive_input) > 0:
                    command, *args = interactive_input
                    if command in ['q', 'exit']:
                        break
                    else:
                        with misc.print_errors():
                            query(command, args, DAEMON_ID)
        else:
            with misc.print_errors():
                query(command, args, DAEMON_ID)
