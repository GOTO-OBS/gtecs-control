#!/usr/bin/env python3
"""A script to provide control over the foc daemon."""

import json
import os
import sys

from gtecs.common import logging
from gtecs.common.system import execute_long_command
from gtecs.control import daemons
from gtecs.control import misc
from gtecs.control import params


def query(command, args):
    """Process a query."""
    daemon_id = os.path.basename(__file__)

    # Primary daemon control
    if command == 'start':
        host, port = daemons.get_daemon_host(daemon_id)
        pid = daemons.start_daemon(daemon_id)
        print(f'Daemon {daemon_id} started on {host}:{port} (PID {pid})')

    elif command == 'shutdown':
        host, port = daemons.get_daemon_host(daemon_id)
        daemons.shutdown_daemon(daemon_id)
        print(f'Daemon {daemon_id} shutdown on {host}:{port}')

    elif command == 'restart':
        host, port = daemons.get_daemon_host(daemon_id)
        pid = daemons.restart_daemon(daemon_id)
        print(f'Daemon {daemon_id} restarted on {host}:{port} (PID {pid})')

    elif command == 'kill':
        host, port = daemons.get_daemon_host(daemon_id)
        daemons.shutdown_daemon(daemon_id, kill=True)
        print(f'Daemon {daemon_id} killed on {host}:{port}')

    elif command in ['check', 'ping']:
        host, port = daemons.get_daemon_host(daemon_id)
        pid = daemons.check_daemon(daemon_id)
        print(f'Daemon {daemon_id} is running on {host}:{port} (PID {pid})')

    elif command in ['info', 'status']:
        if len(args) == 0:
            info_type = 'simple'
            force = False
        elif len(args) == 1 and args[0] in ['f', 'F', '-f', '-F', '--force-update']:
            info_type = 'simple'
            force = True
        elif len(args) == 1 and args[0] in ['v', 'V', '-v', '-V', '--verbose']:
            info_type = 'verbose'
            force = False
        elif len(args) == 1 and args[0] in ['r', 'R', '-r', '-R', '--raw']:
            info_type = 'raw'
            force = False
        elif (len(args) == 2 and
              ((args[0] in ['v', 'V', '-v', '-V', '--verbose'] and
                args[1] in ['f', 'F', '-f', '-F', '--force-update']) or
               (args[1] in ['v', 'V', '-v', '-V', '--verbose'] and
                args[0] in ['f', 'F', '-f', '-F', '--force-update']))):
            info_type = 'verbose'
            force = True
        elif (len(args) == 2 and
              ((args[0] in ['r', 'R', '-r', '-R', '--raw'] and
                args[1] in ['f', 'F', '-f', '-F', '--force-update']) or
               (args[1] in ['r', 'R', '-r', '-R', '--raw'] and
                args[0] in ['f', 'F', '-f', '-F', '--force-update']))):
            info_type = 'raw'
            force = True
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            if info_type != 'raw':
                info_str = daemon.get_info_string(info_type == 'verbose', force)
            else:
                info = daemon.get_info(force)
                info_str = json.dumps(info, indent=2, default=repr)
        print(info_str)

    elif command in ['log', 'tail']:
        if 'stdout' in args:
            log_file = f'{daemon_id}-stdout.log'
            args.remove('stdout')
        else:
            log_file = f'{daemon_id}.log'
        log_path = logging.get_log_path() / log_file
        tail_command = 'tail {} {}'.format(log_path, ' '.join(args))
        execute_long_command(tail_command)

    # Daemon functions
    elif command == 'set':
        if len(args) == 1 and misc.is_num(args[0]):
            # foc set <pos>
            pos = int(args[0])
            pos_dict = {ut: pos for ut in params.UTS_WITH_FOCUSERS}
        elif len(args) == 2 and misc.is_num(args[1]):
            # foc set <ut>[,<ut>...] <pos>
            uts = [int(x) for x in args[0].split(',')]
            pos = int(args[1])
            pos_dict = {ut: pos for ut in uts}
        elif len(args) == 2 and len(args[0].split(',')) == len(args[1].split(',')):
            # foc set <ut>[,<ut>...] <pos>[,<pos>...]
            uts = [int(x) for x in args[0].split(',')]
            pos_list = [int(x) for x in args[1].split(',')]
            pos_dict = {ut: pos for ut, pos in zip(uts, pos_list)}
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            daemon.set_focusers(pos_dict)
        print('Moving Focusers')

    elif command == 'move':
        if len(args) == 1 and misc.is_num(args[0]):
            # foc move <steps>
            steps = int(args[0])
            steps_dict = {ut: steps for ut in params.UTS_WITH_FOCUSERS}
        elif len(args) == 2 and misc.is_num(args[1]):
            # foc move <ut>[,<ut>...] <steps>
            uts = [int(x) for x in args[0].split(',')]
            steps = int(args[1])
            steps_dict = {ut: steps for ut in uts}
        elif len(args) == 2 and len(args[0].split(',')) == len(args[1].split(',')):
            # foc move <ut>[,<ut>...] <steps>[,<steps>...]
            uts = [int(x) for x in args[0].split(',')]
            steps_list = [int(x) for x in args[1].split(',')]
            steps_dict = {ut: steps for ut, steps in zip(uts, steps_list)}
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            daemon.move_focusers(steps_dict)
        print('Moving Focusers')

    elif command == 'home':
        if len(args) == 0:
            # foc home
            uts = params.UTS_WITH_FOCUSERS
        elif len(args) == 1:
            # foc home <ut>[,<ut>...]
            uts = [int(x) for x in args[0].split(',')]
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            daemon.home_focusers(uts)
        print('Homing Focusers')

    elif command in ['stop', 'halt', 'abort']:
        if len(args) == 0:
            # foc stop
            uts = params.UTS_WITH_FOCUSERS
        elif len(args) == 1:
            # foc stop <ut>[,<ut>...]
            uts = [int(x) for x in args[0].split(',')]
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            daemon.stop_focusers(uts)
        print('Stopping Focusers')

    elif command == 'sync':
        if len(args) == 1 and misc.is_num(args[0]):
            # foc sync <position>
            position = int(args[0])
            position_dict = {ut: position for ut in params.UTS_WITH_FOCUSERS}
        elif len(args) == 2 and misc.is_num(args[1]):
            # foc sync <ut>[,<ut>...] <position>
            uts = [int(x) for x in args[0].split(',')]
            position = int(args[1])
            position_dict = {ut: position for ut in uts}
        elif len(args) == 2 and len(args[0].split(',')) == len(args[1].split(',')):
            # foc sync <ut>[,<ut>...] <position>[,<position>...]
            uts = [int(x) for x in args[0].split(',')]
            position_list = [int(x) for x in args[1].split(',')]
            position_dict = {ut: position for ut, position in zip(uts, position_list)}
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            daemon.sync_focusers(position_dict)
        print('Syncing Focusers')

    # Help
    elif command in ['help', '?']:
        print(
            'Usage: foc command [options]',
            'Daemon commands:',
            '  start                          start the daemon',
            '  shutdown                       shutdown the daemon',
            '  restart                        restart the daemon',
            '  kill                           kill the daemon',
            '  check/ping                     check the daemon for errors',
            'Focuser commands:',
            '  move [uts] steps               move by the given steps',
            '  set [uts] pos                  move to the given position',
            '  home [uts]                     move to the home position',
            '  stop/halt/abort [uts]          stop the focusers moving',
            '  sync [uts] pos                 set the current focuser position to the given value',
            '  info/status [-r|-v] [-f]       report current status [raw/verbose/force-update]',
            '  log [stdout]                   print daemon log (tail alias)',
            'Control commands:',
            '  i                              enter interactive mode',
            '  q/exit                         quit interactive mode',
            '  ?/help                         print these instructions',
            sep='\n')

    # Unrecognized function
    else:
        raise ValueError('Unrecognized command "{}"'.format(command))


if __name__ == '__main__':
    try:
        command, *args = sys.argv[1:]
    except ValueError:
        command = 'help'

    if command == 'i':
        while True:
            try:
                interactive_input = input(f'{os.path.basename(__file__)}> ').split()
            except EOFError:
                print()
                sys.exit()
            if len(interactive_input) > 0:
                command, *args = interactive_input
                if command in ['q', 'exit']:
                    sys.exit()
                elif command == 'i':
                    print('Already in interactive mode')
                    continue
                else:
                    query(command, args)
    else:
        query(command, args)
