#!/usr/bin/env python
"""
The G-TeCS script to control operations of the observatory
"""

import os
import sys
import time
import asyncio
import functools
import pkg_resources

from astropy.time import Time
from astropy import units as u

from obsdb import (markJobCompleted, markJobAborted,
                   markJobInterrupted, markJobRunning)

from gtecs.asyncio_protocols import SimpleProtocol
from gtecs import logger
from gtecs import params
from gtecs.slack import send_slack_msg
from gtecs.misc import execute_command, send_email
from gtecs.astronomy import startTime, localMidnight, nightStarting
from gtecs.astronomy import sun_alt as get_sun_alt
from gtecs.observing import filters_are_homed, cameras_are_cool, check_schedule
from gtecs.flags import Conditions, Status
from gtecs.hardware_wrappers import (CameraMonitor, FilterWheelMonitor,
                                     MountMonitor, DomeMonitor,
                                     ExposureQueueMonitor, FocuserMonitor)


SCRIPT_PATH = pkg_resources.resource_filename('gtecs', 'observing_scripts')


class Pilot:
    """
    Run the scheduler and telescope.

    The Pilot uses asyncio to run several tasks concurrently,
    including checking the Scheduler for the best job to
    execute at the moment and then starting an observing job.

    Other tasks include, but are not limited to, logging the status,
    checking for midday (when the pilot shuts down), and checking
    to see if robotic mode is disabled, in which case the Pilot
    should do nothing.

    The most important jobs the pilot has check the observing conditions
    and the emergency shutdown flags. These will close the dome and park
    the mount if necessary.

    The idea behind this version of the Pilot is that it is
    pretty dumb, and simply hands off complicated jobs to
    external scripts, which is runs as a subprocess.
    """
    def __init__(self, testing=False):
        # get a logger for the pilot
        self.log = logger.getLogger('pilot',
                                    log_stdout=True,
                                    log_to_file=params.FILE_LOGGING,
                                    log_to_stdout=params.STDOUT_LOGGING)
        self.log.info('Pilot started')

        # current and next job from scheduler
        self.currentID = None
        self.currentMinTime = None
        self.currentPriority = None
        self.newID = None
        self.newMinTime = None
        self.newPriority = None

        # for communicating with external processes
        self.runningScriptTransport = None
        self.runningScriptProtocol = None
        # future to store result of running script when it's done
        self.runningScriptResult = None

        # a list of all running tasks to cancel at end of night
        # also used to pause and resume operations?
        self.running_tasks = []

        # lists of routine jobs. Each job a dict of name, protocol, cmd and sun_alt
        self.daytime_jobs = []  # before dome opens
        self.evening_jobs = []  # after dome opens
        self.morning_jobs = []  # after observing
        self.startup_complete = False
        self.ready_to_observe = False
        self.observing = False

        # hardware to keep track of and fix if necessary
        self.hardware = dict(
            dome=DomeMonitor(self.log),
            mnt=MountMonitor(self.log),
            cams=CameraMonitor(self.log),
            filts=FilterWheelMonitor(self.log),
            focs=FocuserMonitor(self.log),
            exq=ExposureQueueMonitor(self.log)
        )

        # override and conditions flags
        self.status = Status()
        self.conditions = Conditions()

        # dictionary of reasons to pause
        self.whypause = dict(hw=False, cond=False, manual=False)
        self.time_paused = 0

        # paranoia Time
        self.domeOpen = 0   # should dome be open?
        self.domeConfirmedClosed = 0  # flag indicating that dome is confirmed closed
        self.timeOfLastCloseDomeCommand = 0.
        self.initial_hardware_check_complete = False
        self.initial_scheduler_check_complete = False

        # flag for daytime testing
        self.testing = testing

    @property
    def paused(self):
        """
        Global signal to pause
        """
        return True in self.whypause.values()

    async def waitingForTheSun(self, sun_alt, why,
                               rising=False, ignore_late=False):
        """
        This coroutine will not return until the sun reaches the given altitude

        Parameters
        ----------
        sun_alt : float
            sun altitude in degrees to wait for
        why : str
            a brief reason why we're waiting, helpful for the log
        rising : bool
            whether the sun is rising or setting
        ignore_late : bool, optional
            if true, will ignore checks for if you're too late
            (will still wait if you're too early)

        Returns
        --------
        OK : bool
            True if you are safe to go, False if we think you are too late
        """
        # if the pilot is in testing mode then return immediately
        if self.testing:
            self.log.info('in testing mode, start {} immediately'.format(why))
            return True

        self.log.info('waiting for {}'.format(why))
        now = Time.now()

        # check if we're on the wrong side of midnight
        midnight = localMidnight(nightStarting())
        if not rising and now > midnight:
            # wow, you're really late
            return False
        elif rising and now < midnight:
            return False

        # check if we've missed the sun (with a 5 degree margin)
        if not ignore_late:
            sun_alt_now = get_sun_alt(now)
            if not rising and sun_alt_now < (sun_alt - 5):
                # missed your chance
                return False
            elif rising and sun_alt_now > (sun_alt + 5):
                return False

        # we're on time, so wait until the sun is in the right position
        our_watch_has_ended = False
        while not our_watch_has_ended:
            now = Time.now()
            sun_alt_now = get_sun_alt(now)
            self.log.info('sun alt = {:.1f}, waiting for {:.1f} ({})'.format(sun_alt_now, sun_alt, why))

            if not rising:
                our_watch_has_ended = sun_alt_now < sun_alt
            else:
                our_watch_has_ended = sun_alt_now > sun_alt

            if not our_watch_has_ended:
                await asyncio.sleep(60)

        self.log.info('reached sun alt target, ready for {}'.format(why))
        return True

    async def prepare_for_images_async(self):
        # Home the filter wheels
        if not filters_are_homed():
            execute_command('filt home')
            while not filters_are_homed():
                asyncio.sleep(1)
        self.log.info('filters are homed')

        # Bring the CCDs down to temperature
        if not cameras_are_cool():
            execute_command('cam temp {}'.format(params.CCD_TEMP))
            while not cameras_are_cool():
                asyncio.sleep(1)
        self.log.info('cameras are cool')

    async def runThroughJobList(self, jobList, rising=False,
                                ignore_conditions=False,
                                ignore_late = False):
        """
        Just pop jobs off a list and run them at correct sun_alt
        """
        while jobList:
            job = jobList.pop(0)
            self.log.info('next job: {}'.format(job['name']))

            # wait for the right sun altitude
            OK = await self.waitingForTheSun(job['sunAlt'], job['name'],
                                             rising, ignore_late)

            if not OK:
                # too late
                self.log.warn('too late to start {}'.format(job['name']))
                continue

            elif ((self.whypause['hw']) or (self.whypause['manual']) or
                  (self.whypause['cond'] and not ignore_conditions)):
                # need to check if we're paused
                # if ignore_conditions (daytime jobs) we can start even if
                # paused for conditions, but not for other reasons
                self.log.warn('currently paused, will not start {}'.format(job['name']))
                await asyncio.sleep(15)
                continue

            elif self.testing or ignore_late:
                # wait for each script to finish
                await self.startScript(job['name'], job['protocol'], job['cmd'])

            else:
                # don't wait for script finish, but start each one when the
                # sun alt says so, cancelling running script if not done
                asyncio.ensure_future(
                    self.startScript(job['name'], job['protocol'], job['cmd'])
                )

            await asyncio.sleep(1)

    async def nightMarshall(self, restart=False, late=False):
        """
        The night marshall starts tasks at the right time.

        It does this by polling the sun's altitude.

        Parameters
        ----------
        restart : bool
            If true, we will skip startup jobs and get straight to observing

        late : bool
            If true, we will try to do evening jobs even if it's too late
            (note FLATS will fail anyway)
        """
        self.log.info('nightMarshall initialised')
        # startup. Do this always, unless we're restarting
        if not restart:
            if not self.startup_complete:
                await self.startup()
        self.startup_complete = True

        # daytime jobs. Do these even in bad weather.
        if not restart:
            await self.runThroughJobList(self.daytime_jobs, rising=False,
                                             ignore_conditions=False,
                                             ignore_late=late)

        # make sure filters are homed and cams are cool, in case of restart
        await self.prepare_for_images_async()

        # wait for the right sunalt to open dome
        await self.waitingForTheSun(0, 'OPEN')

        # no point opening if we are paused due to bad weather or hw fault
        while self.paused or not self.initial_hardware_check_complete:
            if self.paused:
                self.log.info('opening suspended until pause is cleared')
            if not self.initial_hardware_check_complete:
                self.log.info('opening suspended until successful hardware check')
            await asyncio.sleep(30)

        # OK - let's open the dome and get ready to observe
        self.log.info('ready to observe')
        self.ready_to_observe = True
        await self.open_dome()
        await self.unpark_mount()

        # run through the routine evening tasks
        if not restart:
            await self.runThroughJobList(self.evening_jobs, rising=False,
                                             ignore_late=late)

        # got here as soon as last evening_job scheduled. wait for darkness
        await self.waitingForTheSun(-15, 'OBS')

        # evening tasks over. Start observing. Will automatically stop at sunAlt
        self.observing = True
        if self.testing:
            await self.observe(until_sun_alt=90)
        else:
            await self.observe(until_sun_alt=-15)
        self.observing = False

        # observing is done. do morning tasks
        await self.runThroughJobList(self.morning_jobs, rising=True,
                                     ignore_late=False)

        # set flag so dome does not reopen
        self.ready_to_observe = False
        self.log.info('nightMarshall completed')

    async def check_scheduler(self):
        """
        Check scheduler and update current job every 10 seconds.
        """
        self.log.info('scheduler check routine initialised')
        while True:
            if not self.observing:
                self.log.debug('scheduler checks disabled when not observing')
                await asyncio.sleep(30)
                continue

            if self.paused:
                self.log.debug('scheduler checks disabled while paused')
                await asyncio.sleep(10)
                continue

            # check scheduler daemon
            self.log.debug('checking scheduler')

            check_results = check_schedule(Time.now(), True)
            self.newID, self.newPriority, self.newMinTime = check_results

            if self.newID != self.currentID:
                self.log.info('scheduler check: NEW JOB {}'.format(self.newID))
            else:
                self.log.info('scheduler check: continue {}'.format(self.currentID))

            self.initial_scheduler_check_complete = True
            await asyncio.sleep(10)

    async def check_hardware(self):
        """
        Continuously monitor hardware and try to fix any issues.
        """
        # monitor until stopped
        sleepTime = 60
        self.log.info('hardware check routine initialised')
        while True:
            if self.status.mode == 'manual':
                self.log.debug('hardware checks suspended in manual mode')
                await asyncio.sleep(sleepTime)
                continue

            if not self.startup_complete:
                self.log.debug('hardware checks disabled until after startup')
                await asyncio.sleep(sleepTime)
                continue

            errCount = 0
            self.log.debug('running hardware checks')
            log_str = 'hardware check results: '
            for device in self.hardware:
                num_errs, err_list = self.hardware[device].check()
                if num_errs > 0:
                    log_str += ' {},{:.0f},{!r}'.format(str(device), num_errs, err_list)
                errCount += num_errs
                if num_errs > 0:
                    self.log.warn('attempting recovery: {}'.format(device))
                    self.hardware[device].recover()

            if errCount > 0:
                # check more frequently till fixed
                sleepTime = 10
                self.log.warn(log_str)
                await self.handlePause('hw', True)
            else:
                sleepTime = 60
                log_str += "AOK"
                self.log.info(log_str)
                await self.handlePause('hw', False)

            self.errCount = errCount  # save error count so we dont restart whilst broken
            self.initial_hardware_check_complete = True
            await asyncio.sleep(sleepTime)

    async def check_flags(self):
        """
        Check the conditions and override flags.

        If overrides.robotic is set we pause running and cancel running script
        If emergency file exists we do an emergency shutdown
        If weather is bad?
        """
        self.log.info('flags check routine initialised')
        while True:

            # overrides
            self.status = Status()
            # conditions flags
            self.conditions = Conditions()

            # handle overrides first
            if self.status.mode == 'manual':
                await self.handlePause('manual', True)
            else:
                await self.handlePause('manual', False)

            # now handle conditions
            self.conditions = Conditions()
            if self.conditions.bad:
                await self.handlePause('cond', True)
            else:
                await self.handlePause('cond', False)

            # emergency file
            if self.status.emergency_shutdown:
                reasons = ', '.join(self.status.emergency_shutdown_reasons)
                asyncio.ensure_future(self.emergency_shutdown(reasons))

            await asyncio.sleep(10)

    async def handlePause(self, reason, pause):
        """
        Called when there may be a change in pause status.

        This checks all the other flags and the current pause status.
        If appropriate it pauses or unpauses operations

        Parameters
        ----------
        reason : string
            the reason why we might pause or unpause
            one of 'manual', 'cond' or 'hw'
        pause : bool
            does reason suggest a pause (True) or unpause (False)
        """
        if pause and not self.whypause[reason]:
            # we can set this here because we want to pause right away
            self.whypause[reason] = True

            if reason == 'cond':
                msg = 'Pausing operations due to bad conditions ({})'.format(self.conditions.bad_flags)
                self.log.warn(msg)

                if self.domeOpen:
                    # don't need to stop if the dome isn't open yet
                    execute_command('exq pause')
                    execute_command('cam abort')
                    await self.cancelRunningScript('conditions bad')

                # always make sure we're closed and parked
                self.close_dome()
                self.park_mount()

            elif reason == 'hw':
                msg = 'Pausing operations due to hardware fault'
                self.log.warn(msg)

                if self.runningScriptProtocol is not None:
                    if self.runningScriptProtocol.jobName == 'STARTUP':
                        # don't cancel startup due to hardware issue
                        pass
                    elif self.runningScriptProtocol.jobName == 'OBS':
                        # just pause the queue until fixed
                        execute_command('exq pause')
                        execute_command('cam abort')
                    else:
                        # other scripts cannot handle losing frames
                        execute_command('exq clear')
                        execute_command('cam abort')
                        await self.cancelRunningScript('hardware fault')

            elif reason == 'manual':
                msg = 'Pausing operations due to manual override'
                self.log.warn(msg)

                # don't actually kill anything, coroutines will pause themselves
                self.log.info('pausing for pilot for manual override')
                self.log.info('current job will continue')

        # does this change suggest a global unpause?
        unpause = not any([self.whypause[key] for key in self.whypause.keys()
                           if key != reason]) and not pause
        if unpause and self.paused:
            # OK, we can resume
            self.log.warn('resuming operations')
            if self.ready_to_observe:
                if not self.domeOpen:
                    # this way we don't
                    # start until the dome is open
                    await self.open_dome()
                await self.unpark_mount()
                execute_command('exq resume')

        # finally, change global pause status by updating flag
        # by putting this last, we dont unpause until the dome
        # is actually open or HW is fixed etc.
        self.whypause[reason] = pause

    async def check_dome(self):
        """
        Be extra cautious and double check that dome is closed if it should be
        """
        self.log.info('dome check routine initialised')
        while True:
            if self.status.mode == 'manual':
                self.log.debug('dome checks suspended in manual mode')
                await asyncio.sleep(10)
                continue

            if not self.domeOpen and not self.domeConfirmedClosed:
                dome_info = self.hardware['dome'].getInfo()
                if dome_info['dome'] == 'closed':
                    # phew
                    self.domeConfirmedClosed = 1
                    self.log.info('dome confirmed closed')
                elif time.time() - self.timeOfLastCloseDomeCommand > 65.:
                    self.log.warn('dome not closed. Trying again...')
                    self.close_dome()
            await asyncio.sleep(10)

    async def check_time_paused(self):
        self.log.info('pause check routine initialised')
        while True:
            if self.paused:
                self.time_paused += 60
            await asyncio.sleep(60)

    async def observe(self, until_sun_alt=-15):
        """
        Observe until further notice.

        Parameters
        ----------
        until_sun_alt : float
            sun altitude at which to stop observing
        """
        self.log.info("observing")

        while True:

            # do nothing if paused
            if self.paused:
                await asyncio.sleep(30)
                continue

            # no point observing if we haven't checked the scheduler yet
            while not self.initial_scheduler_check_complete:
                self.log.info('waiting for first scheduler check')
                await asyncio.sleep(30)
                continue

            # should we stop for the sun?
            now = Time.now()
            midnight = localMidnight(nightStarting())
            sun_alt_now = get_sun_alt(now)
            if now > midnight and sun_alt_now > until_sun_alt:
                self.log.info('observing completed!')
                # finish observing
                execute_command('exq clear')
                execute_command('cam abort')
                # in fringe case where we've interrupted a job it needs
                # to be cancelled.
                await self.cancelRunningScript('obs finished')

                # Mark the pointing
                # this will fail if obsStartTime not currently defined
                try:
                    timeElapsed = time.time() - self.obsStartTime - self.time_paused
                except:
                    # in which case...
                    timeElapsed = 0
                self.log.info('min time = {:.1f}, time elapsed = {:.1f}'.format(
                    self.currentMinTime, timeElapsed
                ))
                if timeElapsed > self.currentMinTime:
                    markJobCompleted(self.currentID)
                    self.log.info('job completed: {}'.format(self.currentID))
                else:
                    markJobInterrupted(self.currentID)
                    self.log.info('job interrupted: {}'.format(self.currentID))

                self.currentID = None
                self.currentPriority = None
                self.currentMinTime = None

                return

            # see if a new target has arrived and mark job appropriately
            if self.currentID != self.newID:
                if self.currentID is not None:
                    self.log.info('got new job from scheduler {}'.format(self.newID))
                    # this will fail if obsStartTime not currently defined
                    try:
                        timeElapsed = time.time() - self.obsStartTime - self.time_paused
                    except:
                        # in which case...
                        timeElapsed = 0
                    self.log.info('min time = {:.1f}, time elapsed = {:.1f}'.format(
                        self.currentMinTime, timeElapsed
                    ))
                    if timeElapsed > self.currentMinTime:
                        markJobCompleted(self.currentID)
                        self.log.info('job completed: {}'.format(self.currentID))
                    else:
                        markJobInterrupted(self.currentID)
                        self.log.info('job interrupted: {}'.format(self.currentID))
                else:
                    self.log.info('got job from scheduler {}'.format(self.newID))

                # start new job
                if self.newID is None:
                    # park mount
                    self.park_mount()
                    execute_command('exq clear')
                    execute_command('cam abort')
                    self.currentID = self.newID
                    self.currentPriority = None
                    self.currentMinTime = None
                    # in fringe case where we've interrupted a job it needs
                    # to be cancelled.
                    await self.cancelRunningScript('obs parking')
                else:
                    cmd = [os.path.join(SCRIPT_PATH, 'observe.py'),
                           str(self.newID), str(int(self.newMinTime))]
                    self.log.info('starting Job {}'.format(self.newID))
                    markJobRunning(self.newID)
                    self.obsStartTime = time.time()
                    self.time_paused = 0
                    # start job, will cancel current one automatically
                    asyncio.ensure_future(
                        self.startScript('OBS', SimpleProtocol, cmd)
                    )
                    self.currentID = self.newID
                    self.currentPriority = self.newPriority
                    self.currentMinTime = self.newMinTime

            else:  # we are doing the right job, so do nothing
                if self.currentID is None:
                    self.log.info('nothing to observe!')
                else:
                     self.log.debug('still observing {}'.format(self.currentID))
                await asyncio.sleep(5)

    async def cancelRunningScript(self, why):
        """
        Cancel the currently running Python script.

        This does nothing if the script is already done.
        """
        if self.runningScriptTransport is not None:
            # check job is still running
            if self.runningScriptTransport.get_returncode() is None:
                name = self.runningScriptProtocol.jobName
                self.log.info('killing {}, reason: "{}"'.format(name, why))

                execute_command('exq clear')
                execute_command('cam abort')

                # if we were observing, mark as aborted
                if name == 'OBS' and self.currentID is not None:
                    markJobAborted(self.currentID)

                self.runningScriptTransport.terminate()
                await self.runningScriptResult
                self.log.info("killed {}".format(name))

    async def startScript(self, name, protocol, cmd):
        """
        Launch an external Python script.

        Parameters
        ----------
        name : str
            A name for this process. Prepended to output from process.
        protocol : `pilot_protocols.PilotJobProtocol`
            Protocol used to process output from Process
        cmd : list
            A list of the command to be executed with Python. The
            first element of the list is the Python script to execute,
            any additional elements are the arguments to the script.
        """
        # first, cancel any currently running script
        await self.cancelRunningScript(why='new script starting')

        # future to store result in
        self.runningScriptResult = asyncio.Future()
        # fill the name, future and logName arguments of protocol(...)
        # using functools.partial
        factory = functools.partial(protocol, name, self.runningScriptResult,
                                    'pilot')
        loop = asyncio.get_event_loop()

        # create the process coroutine which will return
        # a 'transport' and 'protocol' when scheduled
        proc = loop.subprocess_exec(factory, sys.executable, '-u', *cmd,
                                    stdin=None)

        # start the process and get transport and protocol for control of it
        self.log.info("starting {}".format(name))
        self.runningScriptTransport, self.runningScriptProtocol = await proc
        # process started, await completion
        retcode, result = await self.runningScriptResult
        # done
        self.log.info("finished {}".format(name))
        return retcode, result

    async def waitForNightsEnd(self, stopTime, sleepTime=120):
        """
        Function returns when night is done.

        This function simply keeps running until the stopTime is reached.
        The use of such a function is that it can be added to the list
        of tasks supplied to `~asyncio.BaseEventLoop.run_until_complete`
        and the loop will keep going until the stopTime is reached.

        Sleeps periodically to allow other jobs to be done.

        Parameters
        -----------
        stopTime : `~astropy.time.Time`
            the time to stop the Pilot
        sleepTime : float or int
            the time to sleep between checks against `stopTime`
        """
        while Time.now() < stopTime:
            now = Time.now()
            stopTime.precision = 0
            delta = stopTime - now
            status_str = 'end of night at {} ({:.0f} mins)'.format(stopTime.iso, delta.to('min').value)
            self.log.info(status_str)
            if self.paused:
                reasons = [k for k in self.whypause if self.whypause[k]]
                reasons = ', '.join(reasons)
                self.log.info('pilot paused ({})'.format(reasons))
                await asyncio.sleep(30)
            else:
                await asyncio.sleep(sleepTime)

        self.log.info('stopTime reached, night is over')
        await self.shutdown()

        self.log.info('finished for tonight')

    async def reallyReallyCloseDome(self, time_until_panic=10):
        """
        Close the dome, make sure it's closed and email if it won't

        Parameters
        ----------
        time_until_panic : float
            time in minutes to wait before emailing
        """
        start_time = time.time()
        self.close_dome()
        domeShut = False
        while not domeShut:
            elapsed_time = time.time() - start_time
            # if we've waited too long,  email
            if elapsed_time / 60. > time_until_panic:
                msg = "IMPORTANT: pilot cannot close dome. Take action immediately."
                send_email(message=msg)
                send_slack_msg(msg)
            dome_info = self.hardware['dome'].getInfo()
            if dome_info['dome'] == 'closed':
                domeShut = True
            self.log.info('Waiting for dome to close')
            await asyncio.sleep(10)
        self.log.info('Dome closed')

    async def startup(self):
        """
        Start up the system

        Runs the startup script, and sets the startup_complete flag
        """

        # start startup script
        self.log.info('running startup script')
        cmd=[os.path.join(SCRIPT_PATH, 'startup.py')]
        retcode, result = await self.startScript('STARTUP', SimpleProtocol, cmd)
        if retcode != 0:
            self.log.warn('STARTUP ended abnormally')

        self.log.info('startup process complete')

    async def shutdown(self):
        """
        Shut down the system

        Close any running scripts and jobs, run the shutdown script, ensure the
        dome is closed and finish.
        """

        # first, cancel any currently running script
        await self.cancelRunningScript(why='shutdown started')

        # close any running tasks, so check_flags
        # doesn't initiate two shutdowns
        self.log.warn('cancelling running tasks')
        for task in self.running_tasks:
            task.cancel()

        # start shutdown script
        self.log.warn('running shutdown script')
        cmd=[os.path.join(SCRIPT_PATH, 'shutdown.py')]
        retcode, result = await self.startScript('SHUTDOWN', SimpleProtocol, cmd)
        if retcode != 0:
            self.log.warn('SHUTDOWN ended abnormally')

        # next and most important.
        # NEVER STOP WITHOUT CLOSING THE DOME!
        # EMAIL IF DOME WON'T CLOSE
        self.log.warn('making sure dome is closed')
        await self.reallyReallyCloseDome()

        self.log.warn('shutdown process complete')

    async def emergency_shutdown(self, why):
        """
        Send a warning and then shut down
        """
        self.log.warn('performing emergency shutdown: {}'.format(why))
        send_slack_msg('{} pilot is performing an emergency shutdown: {}'.format(
                       params.TELESCOP, why))

        self.log.warn('closing dome immediately')
        if self.domeOpen:
            self.close_dome()

        self.log.warn('running shutdown')
        await self.shutdown()

    async def open_dome(self):
        self.log.warn('opening dome')
        execute_command('dome open')
        self.domeOpen = 1
        # make sure the dome starts reporting errors
        self.hardware['dome'].setMode('open')
        self.domeConfirmedClosed = 0
        while self.domeStatus() != 'full_open':
            await asyncio.sleep(5)
        self.log.info('dome is open')

    def domeStatus(self):
        try:
            dome_info = self.hardware['dome'].getInfo()
            if dome_info['dome'] == 'closed':
                return 'closed'
            if (dome_info['north'] == 'full_open' and
                    dome_info['south'] == 'full_open'):
                return 'full_open'
            return 'part_open'
        except:
            return 'err'

    def close_dome(self):
        self.log.warn('closing dome')
        execute_command('dome close')
        self.domeOpen = 0
        # make sure the dome starts reporting errors
        self.hardware['dome'].setMode(None)
        self.domeConfirmedClosed = 0
        self.timeOfLastCloseDomeCommand = time.time()

    def park_mount(self):
        self.log.warn('parking mount')
        if params.FREEZE_DEC:
            execute_command('mnt stop')
        else:
            execute_command('mnt park')
        self.hardware['mnt'].setMode('parked')

    async def unpark_mount(self):
        mnt_info = self.hardware['mnt'].getInfo()
        if mnt_info['status'] == 'Parked':
            self.log.warn('unparking mount')
            execute_command('mnt unpark')
            self.hardware['mnt'].setMode('tracking')
            await asyncio.sleep(5)

        # slew to above horizon, to stop errors
        execute_command('mnt slew_altaz 50 0')
        await asyncio.sleep(10)

        mnt_info = self.hardware['mnt'].getInfo()
        if mnt_info['status'] != 'Tracking':
            execute_command('mnt track')
            await asyncio.sleep(2)


    def assignJobs(self):
        # daytime jobs: to do before opening the dome
        darks = dict(name='DARKS', sunAlt=8,
                     cmd=[os.path.join(SCRIPT_PATH, 'takeBiasesAndDarks.py'), str(params.NUM_DARKS)],
                     protocol=SimpleProtocol)
        self.daytime_jobs = [darks]

        # evening jobs: to do after opening but before starting observing
        flats_e = dict(name='FLATS', sunAlt=-1,
                      cmd=[os.path.join(SCRIPT_PATH, 'takeFlats.py'), 'EVE'],
                      protocol=SimpleProtocol)
        #std = dict(name='STD', sunAlt=-10,
        #           cmd=[os.path.join(SCRIPT_PATH, 'takeStandards.py')],
        #           protocol=SimpleProtocol)
        foc = dict(name='FOC', sunAlt=-11,
                   cmd=[os.path.join(SCRIPT_PATH, 'autoFocus.py')],
                   protocol=SimpleProtocol)
        self.evening_jobs = [flats_e, foc]

        # morning jobs: to do after finishing observing but before closing
        flats_m = dict(name='FLATS', sunAlt=-10,
                       cmd=[os.path.join(SCRIPT_PATH, 'takeFlats.py'), 'MORN'],
                       protocol=SimpleProtocol)
        self.morning_jobs = [flats_m]


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-t', '--test', action="store_true", default=False)
    parser.add_argument('-r', '--restart', action="store_true", default=False)
    parser.add_argument('-l', '--late', action="store_true", default=False)
    args = parser.parse_args()

    loop = asyncio.get_event_loop()
    loop.set_debug(False)
    pilot = Pilot(testing=args.test)
    pilot.assignJobs()

    # start the recurrent tasks
    pilot.running_tasks.extend([
        asyncio.ensure_future(pilot.check_hardware()),  # periodically check hardware
        asyncio.ensure_future(pilot.check_time_paused()),  # keep track of time paused
        asyncio.ensure_future(pilot.check_flags()),  # check flags for bad weather or override
        asyncio.ensure_future(pilot.check_scheduler()),  # start checking the schedule
        asyncio.ensure_future(pilot.check_dome()),  # keep a close eye on dome
        asyncio.ensure_future(pilot.nightMarshall(args.restart, args.late)),  # run through scheduled jobs
    ])

    # keep the pilot runing until the end of the night
    if pilot.testing:
        sunrise = Time.now() + 60*u.minute
    else:
        date = nightStarting()
        sunrise = startTime(date, 0*u.deg, eve=False)
    stopSignal = pilot.waitForNightsEnd(stopTime=sunrise)

    try:
        # actually start the event loop - nothing happens until this line is reached!
        loop.run_until_complete(stopSignal)
    except asyncio.CancelledError:
        print('Tasks cancelled')
    finally:
        print('Pilot done')
        loop.close()
