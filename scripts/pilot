#!/usr/bin/env python

########################################################################
#                               pilot.py                               #
#           ~~~~~~~~~~~~~~~~~~~~~~~##~~~~~~~~~~~~~~~~~~~~~~~           #
#           G-TeCS script to control operations of observatory         #
#            Martin Dyer & Stuart Littlefair, Sheffield, 2016          #
#           ~~~~~~~~~~~~~~~~~~~~~~~##~~~~~~~~~~~~~~~~~~~~~~~           #
#                   Based on the SLODAR/pt5m system                    #
########################################################################

import asyncio
import sys
import os
import functools
import pkg_resources

from astropy.time import Time
from astropy import units as u

from gtecs.tecs_modules.testScheduler import Scheduler
from gtecs.tecs_modules.asyncio_protocols import SimpleProtocol
from gtecs.tecs_modules import logger
from gtecs.tecs_modules import params
from gtecs.tecs_modules.astronomy import sun_alt

scheduler = Scheduler()

SCRIPT_PATH = pkg_resources.resource_filename('gtecs', 'observing_scripts')


class Pilot:
    """
    Run the scheduler and telescope.

    The Pilot uses asyncio to run several tasks concurrently,
    including checking the Scheduler for the best job to
    execute at the moment and then starting an observing job.

    Other tasks include, but are not limited to, logging the status,
    checking for midday (when the pilot shuts down), and checking
    to see if robotic mode is disabled, in which case the Pilot
    should do nothing.

    The most important jobs the pilot has check the observing conditions
    and the emergency shutdown flags. These will close the dome and park
    the scope if necessary.

    The idea behind this version of the Pilot is that it is
    pretty dumb, and simply hands off complicated jobs to
    external scripts, which is runs as a subprocess.
    """
    def __init__(self):
        # get a logger for the pilot
        self.log = logger.getLogger('pilot',
                                    file_logging=params.FILE_LOGGING,
                                    stdout_logging=params.STDOUT_LOGGING)

        # current and next job from scheduler
        self.currJob = None
        self.nextJob = None

        # for communicating with external processes
        self.runningScriptTransport = None
        self.runningScriptProtocol = None
        # future to store result of running script when it's done
        self.runningScriptResult = None

        # a list of all running tasks to cancel at end of night
        self.running_tasks = []

        # lists of routine jobs. Each job a dict of name, protocol, cmd and sun_alt
        self.morning_jobs = []
        self.evening_jobs = []

    async def waitingForTheSun(self, sunAlt, rising=False):
        """
        This coroutine will not return until the sun reaches the given altitude

        Parameters
        ----------
        sunAlt : float
            sun altitude in degrees to wait for
        rising : bool
            whether the sun is rising or setting
        """
        our_watch_has_ended = False
        while not our_watch_has_ended:
            sun_alt_now = sun_alt(Time.now())
            if rising:
                our_watch_has_ended = sun_alt_now > sunAlt
            else:
                our_watch_has_ended = sun_alt_now < sunAlt
            await asyncio.sleep(20)

    async def nightMarshall(self, restart=False):
        """
        The night marshall starts tasks at the right time.

        It does this by polling the sun's altitude.

        Parameters
        ----------
        restart : bool
            If true, we will skip startup jobs and get straight to observing
        """
        # run through the routine evening tasks
        if not restart:
            while self.evening_jobs:
                job = self.evening_jobs.pop(0)
                # wait for the right sun altitude
                await self.waitingForTheSun(job['sunAlt'], rising=False)
                # and go!
                asyncio.ensure_future(
                    self.startScript(job['name'], job['protocol'], job['cmd'])
                )

        # evening tasks over. Start observing. Will automatically stop at sunAlt
        await self.observe(until_sun_alt=-15)

        # observing is done. do morning tasks
        while self.morning_jobs:
            job = self.morning_jobs.pop(0)
            # wait for the sun altitude
            await self.waitingForTheSun(job['sunAlt'], rising=True)
            asyncio.ensure_future(
                    self.startScript(job['name'], job['protocol'], job['cmd'])
            )

    async def nightPlan(self):
        """
        Chain coroutines together to make a night plan.

        Just runs them all in sequence at the moment. Have to
        think about how best to schedule stuff to run at
        correct times (see also nightMarshall).
        """
        self.log.info("Starting the night")

        # Start DAEMONS
        cmd = [os.path.join(SCRIPT_PATH, 'start_daemons.py')]
        retcode, results = await self.startScript('DAE', SimpleProtocol, cmd)
        if retcode != 0:
            self.log.warn('DAE ended abnormally')

        cmd = [os.path.join(SCRIPT_PATH, 'start_of_night_1.py')]
        retcode, results = await self.startScript('SN1', SimpleProtocol, cmd)
        if retcode != 0:
            self.log.warn('SN1 ended abnormally')

        cmd = [os.path.join(SCRIPT_PATH, 'start_of_night_2.py')]
        retcode, results = await self.startScript('SN2', SimpleProtocol, cmd)
        if retcode != 0:
            self.log.warn('SN2 ended abnormally')

        # take biasses and darks, 3 of each
        # cmd = [os.path.join(SCRIPT_PATH, 'start_of_night_3.py'), '3']
        # retcode, results = await self.startScript('SN3', SimpleProtocol, cmd)
        # if retcode != 0:
        #    self.log.warn('SN3 ended abnormally')

        # take evening flats
        cmd = [os.path.join(SCRIPT_PATH, 'takeFlats.py'), 'EVE']
        retcode, results = await self.startScript('FLATS', SimpleProtocol, cmd)
        if retcode != 0:
            self.log.warn('FLATS ended abnormally')

        # autofocus

        # take standards

        # await self.observe()

        # morning flats

        # shutdown daemons

        # power off
        self.log.info("Night done")

    async def checkSchedule(self):
        """
        Check sheduler and update current job every second
        """
        while True:
            self.nextJob = scheduler()
            await asyncio.sleep(1)

    async def cancelRunningScript(self):
        """
        Cancel the currently running Python script.

        This does nothing if the script is already done.
        """
        if self.runningScriptTransport is not None:
            # check job is still running
            if self.runningScriptTransport.get_returncode() is None:
                self.log.info("Killing {}".format(self.runningScriptProtocol.jobName))
                self.runningScriptTransport.terminate()
                await self.runningScriptResult

    async def observe(self):
        """
        Observe until further notice.

        Successful observing should:
            - start a coroutine to check the scheduler
            - loop to handle starting and cancelling observations
        """
        self.log.info("Observing")

        # start checking Schedule
        # normally, we'd do this when the pilot starts, but
        # the fake scheduler only has a few tasks in it, sorted
        # we leave it until observing starts so we don't run
        # out of jobs.
        self.running_tasks.append(
            asyncio.ensure_future(self.checkSchedule())
        )

        while True:
            # check we're doing the right job
            if (self.currJob != self.nextJob) and self.nextJob[0] is not None:
                if self.currJob is not None:
                    self.log.info("Got new job from scheduler %s", self.nextJob[0])
                else:
                    self.log.info("Got first job from scheduler %s", self.nextJob[0])

                # start new job
                self.currJob = self.nextJob
                name, duration = self.currJob

                cmd = [os.path.join(SCRIPT_PATH, 'observe.py'), name, str(duration)]
                self.log.info('{} will take {} seconds'.format(name, duration))
                # start process
                asyncio.ensure_future(
                    self.startScript('OBS', SimpleProtocol, cmd)
                )

            else:  # we are doing the right job, so do nothing
                await asyncio.sleep(1)

    async def startScript(self, name, protocol, cmd):
        """
        Launch an external Python script.

        Parameters
        ----------
        name : str
            A name for this process. Prepended to output from process.
        protocol : `pilot_protocols.PilotJobProtocol`
            Protocol used to process output from Process
        cmd : list
            A list of the command to be executed with Python. The
            first element of the list is the Python script to execute,
            any additional elements are the arguments to the script.
        """
        # first, cancel any currently running script
        await self.cancelRunningScript()

        # future to store result in
        self.runningScriptResult = asyncio.Future()
        # fill the name, future and logName arguments of protocol(...)
        # using functools.partial
        factory = functools.partial(protocol, name, self.runningScriptResult,
                                    'pilot')
        loop = asyncio.get_event_loop()
        '''
        create the process coroutine which will return
        a 'transport' and 'protocol' when scheduled
        '''
        proc = loop.subprocess_exec(
            factory,
            sys.executable, '-u',  # sys.executable is Python, '-u' to flush stdout
            *cmd,
            stdin=None,
            stderr=None
        )
        # start the process and get transport and protocol for control of it
        self.runningScriptTransport, self.runningScriptProtocol = await proc
        # process started, await completion
        retcode = await self.runningScriptResult
        # done
        return retcode

    async def waitForNightsEnd(self, stopTime, sleepTime=1):
        """
        Function returns when night is done.

        This function simply keeps running until the stopTime is reached.
        The use of such a function is that it can be added to the list
        of tasks supplied to `~asyncio.BaseEventLoop.run_until_complete`
        and the loop will keep going until the stopTime is reached.

        Sleeps periodically to allow other jobs to be done.

        Parameters
        -----------
        stopTime : `~astropy.time.Time`
            the time to stop the Pilot
        sleepTime : float or int
            the time to sleep between checks against `stopTime`
        """
        while Time.now() < stopTime:
            self.log.info(Time.now())
            await asyncio.sleep(10)

        # if we have external subprocess running, stop it
        await self.cancelRunningScript()

        # close any running tasks
        for future in self.running_tasks:
            future.cancel()

        self.log.info("Done")


if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    pilot = Pilot()

    # start the night plan
    pilot.running_tasks.append(
        asyncio.ensure_future(pilot.nightPlan())
    )

    stopSignal = pilot.waitForNightsEnd(Time.now() + 10*u.minute)
    # keep the pilot runing until the end of the night
    try:
        loop.run_until_complete(stopSignal)
    except asyncio.CancelledError:
        print('Tasks cancelled')
    finally:
        print("Pilot Done")
        loop.close()
