#!/usr/bin/env python

########################################################################
#                               pilot.py                               #
#           ~~~~~~~~~~~~~~~~~~~~~~~##~~~~~~~~~~~~~~~~~~~~~~~           #
#           G-TeCS script to control operations of observatory         #
#            Martin Dyer & Stuart Littlefair, Sheffield, 2016          #
#           ~~~~~~~~~~~~~~~~~~~~~~~##~~~~~~~~~~~~~~~~~~~~~~~           #
#                   Based on the SLODAR/pt5m system                    #
########################################################################

import asyncio
import sys
import os
import functools
import pkg_resources
import time

from astropy.time import Time
from astropy import units as u

from gtecs.tecs_modules.testScheduler import Scheduler
from gtecs.tecs_modules.asyncio_protocols import SimpleProtocol
from gtecs.tecs_modules import logger
from gtecs.tecs_modules import params
from gtecs.tecs_modules.time_date import nightStarting
from gtecs.database import (markJobCompleted, markJobAborted,
                            markJobInterrupted, markJobRunning)
from gtecs.tecs_modules.misc import execute_command, send_email
from gtecs.tecs_modules.astronomy import sun_alt
from gtecs.tecs_modules.flags import (Conditions, Overrides)
from gtecs.tecs_modules.hardware_wrappers import (CameraMonitor, FilterWheelMonitor,
                                                  MountMonitor, DomeMonitor, ExposureQueueMonitor,
                                                  FocuserMonitor)
scheduler = Scheduler()

SCRIPT_PATH = pkg_resources.resource_filename('gtecs', 'observing_scripts')


class Pilot:
    """
    Run the scheduler and telescope.

    The Pilot uses asyncio to run several tasks concurrently,
    including checking the Scheduler for the best job to
    execute at the moment and then starting an observing job.

    Other tasks include, but are not limited to, logging the status,
    checking for midday (when the pilot shuts down), and checking
    to see if robotic mode is disabled, in which case the Pilot
    should do nothing.

    The most important jobs the pilot has check the observing conditions
    and the emergency shutdown flags. These will close the dome and park
    the scope if necessary.

    The idea behind this version of the Pilot is that it is
    pretty dumb, and simply hands off complicated jobs to
    external scripts, which is runs as a subprocess.
    """
    def __init__(self, testing=False):
        # get a logger for the pilot
        self.log = logger.getLogger('pilot',
                                    file_logging=params.FILE_LOGGING,
                                    stdout_logging=params.STDOUT_LOGGING)

        # current and next job from scheduler
        self.currentID = None
        self.currentMinTime = None
        self.currentPriority = None
        self.newID = None
        self.newMinTime = None
        self.newPriority = None

        # for communicating with external processes
        self.runningScriptTransport = None
        self.runningScriptProtocol = None
        # future to store result of running script when it's done
        self.runningScriptResult = None

        # a list of all running tasks to cancel at end of night
        # also used to pause and resume operations?
        self.running_tasks = []

        # lists of routine jobs. Each job a dict of name, protocol, cmd and sun_alt
        self.daytime_jobs = []  # before dome opens
        self.morning_jobs = []  # after dome opens
        self.evening_jobs = []  # after observing
        self.ready_to_observe = False

        # hardware to keep track of and fix if necessary
        self.hardware = dict(
            dome=DomeMonitor(self.log),
            mnt=MountMonitor(self.log),
            cams=CameraMonitor(self.log),
            filts=FilterWheelMonitor(self.log),
            focs=FocuserMonitor(self.log),
            exq=ExposureQueueMonitor(self.log)
        )

        # override and conditions flags
        self.overrides = None
        self.conditions = None

        # dictionary of reasons to pause
        self.whypause = dict(hw=False, cond=False, manual=False)

        # paranoia Time
        self.domeOpen = 0   # should dome be open?
        self.domeConfirmedClosed = 0  # flag indicating that dome is confirmed closed
        self.timeOfLastCloseDomeCommand = 0.

        # flag for daytime testing
        self.testing = testing

    @property
    def paused(self):
        """
        Global signal to pause
        """
        return True in self.whypause.values()

    async def waitingForTheSun(self, sunAlt, rising=False):
        """
        This coroutine will not return until the sun reaches the given altitude

        Parameters
        ----------
        sunAlt : float
            sun altitude in degrees to wait for
        rising : bool
            whether the sun is rising or setting
        testing : bool, optional
            if true, immediately returns OK without checking the sun.
            used for testing the pilot only

        Returns
        --------
        OK : bool
            True if you are safe to go, False if we think you are too late
        """
        if self.testing:
            return True

        sun_alt_now = sun_alt(Time.now())
        if rising and (sun_alt_now - sunAlt) > 5:
            return False
        if not rising and (sunAlt - sun_alt_now) > 5:
            return False

        our_watch_has_ended = False
        while not our_watch_has_ended:
            sun_alt_now = sun_alt(Time.now())
            self.log.info('waiting: sun altitude = {}'.format(sun_alt_now))
            if rising:
                our_watch_has_ended = sun_alt_now > sunAlt
            else:
                our_watch_has_ended = sun_alt_now < sunAlt
            await asyncio.sleep(20)
        return True

    async def runThroughJobList(self, jobList, rising=False):
        """
        Just pop jobs off a list and run them at correct sun_alt
        """
        while jobList:
            if self.paused:  # do nothing if paused
                await asyncio.sleep(15)
                continue
            job = jobList.pop(0)
            # wait for the right sun altitude
            OK = await self.waitingForTheSun(job['sunAlt'], rising=rising)
            # and go!
            if OK:
                if self.testing:
                    # wait for each script to finish
                    await self.startScript(job['name'], job['protocol'], job['cmd'])
                else:
                    # don't wait for script finish, but start each one when the
                    # sun alt says so, cancelling running script if not done
                    asyncio.ensure_future(
                        self.startScript(job['name'], job['protocol'], job['cmd'])
                    )
            else:
                self.log.warn('too late to start {}'.format(job['name']))
            await asyncio.sleep(1)

    async def nightMarshall(self, restart=False):
        """
        The night marshall starts tasks at the right time.

        It does this by polling the sun's altitude.

        Parameters
        ----------
        restart : bool
            If true, we will skip startup jobs and get straight to observing
        """
        # daytime jobs
        if not restart:
            await self.runThroughJobList(self.daytime_jobs, rising=False)

        # done the daytime jobs. Set flag to allow open dome
        self.ready_to_observe = True
        await self.open_dome()

        # run through the routine evening tasks
        if not restart:
            await self.runThroughJobList(self.evening_jobs, rising=False)

        # evening tasks over. Start observing. Will automatically stop at sunAlt
        if self.testing:
            await self.observe(until_sun_alt=90)
        else:
            await self.observe(until_sun_alt=-15)

        # observing is done. do morning tasks
        await self.runThroughJobList(self.morning_jobs, rising=True)

        # set flag so dome does not reopen
        self.ready_to_observe = False

    async def checkSchedule(self):
        """
        Check sheduler and update current job every 5 seconds
        """
        while True:
            if self.paused:
                await asyncio.sleep(5)
                continue
            self.newID, self.newPriority, self.newMinTime = scheduler()
            self.log.info('current Job: {}, new Job: {}'.format(self.currentID, self.newID))
            await asyncio.sleep(5)

    async def hardwareChecks(self):
        """
        Continuously monitor hardware and try to fix any issues.
        """
        # monitor until stopped
        while True:
            errCount = 0
            self.log.info('running hardware checks')
            log_str = 'hardware check results: '
            for device in self.hardware:
                num_errs, err_list = self.hardware[device].check()
                if num_errs > 0:
                    log_str += ' %s,%s,%s' % (str(device), str(num_errs), repr(err_list))
                errCount += num_errs
                if num_errs > 0:
                    self.log.warn('attempting recovery: {}'.format(device))
                    self.hardware[device].recover()

            if errCount > 0:
                self.log.warn(log_str)
                await self.handlePause('hw', True)
            else:
                log_str += "AOK"
                self.log.info(log_str)
                await self.handlePause('hw', False)

            self.errCount = errCount  # save error count so we dont restart whilst broken
            await asyncio.sleep(60)

    async def check_flags(self):
        """
        Check the conditions and override flags.

        If overrides.robotic is set we pause running and cancel running script
        If emergency file exists we do an emergency shutdown
        If weather is bad?
        """
        while True:

            # overrides
            self.overrides = Overrides()
            # conditions flags
            self.conditions = Conditions()

            # handle overrides first
            if self.overrides.robotic:
                await self.handlePause('manual', True)
            else:
                await self.handlePause('manual', False)

            # now handle conditions
            self.conditions = Conditions()
            if self.conditions.bad:
                await self.handlePause('cond', True)
            else:
                await self.handlePause('cond', False)

            # emergency file
            if os.path.isfile(params.EMERGENCY_FILE):
                await self.emergency_shutdown()

            await asyncio.sleep(10)

    async def handlePause(self, reason, pause):
        """
        Called when there may be a change in pause status.

        This checks all the other flags and the current pause status.
        If appropriate it pauses or unpauses operations

        Parameters
        ----------
        reason : string
            the reason why we might pause or unpause
            one of 'manual', 'cond' or 'hw'
        pause : bool
            does reason suggest a pause (True) or unpause (False)
        """
        if not self.paused and pause:
            # ok, we need to cancel what we were doing!
            msg = 'Pausing operations due to '
            if reason == 'manual':
                msg += "manual override"
            if reason == 'cond':
                msg += 'weather\n'
                msg += '{!r}'.format(self.conditions.__dict__)
            if reason == 'hw':
                msg += 'hardware fault'
            self.log.warn(msg)
            # is this necessary? or will all jobs gracefull handle pause in queue?
            # self.cancelRunningScript()

            if reason == 'cond':
                # if the reason is weather, handle dome open/close
                # also park mount and pause queue
                self.log.warn('closing and parking')
                execute_command('mnt park')
                execute_command('exq pause')
                execute_command('cam abort')
                if self.domeOpen:
                    self.close_dome()
            elif reason == 'hw':
                # just pause the queue until fixed
                execute_command('exq pause')
                execute_command('cam abort')
            else:
                self.log.info('pausing for pilot for manual override')
                self.log.info('current job will continue')

        # does this change suggest a global unpause?
        unpause = not any([self.whypause[key] for key in self.whypause.keys()
                           if key != reason]) and not pause
        if unpause and self.paused:
            # OK, we can resume
            self.log.warn('resuming operations')
            if self.ready_to_observe:
                execute_command('mnt unpark')
                await asyncio.sleep(10)
                execute_command('mnt track')
                if not self.domeOpen:
                    # this way we don't start this way we don't
                    # start until the dome is open
                    await self.open_dome()
                execute_command('exq resume')

        # finally, change global pause status by updating flag
        # by putting this last, we dont unpause until the dome
        # is actually open or HW is fixed etc.
        self.whypause[reason] = pause

    async def doubleCheckDome(self):
        """
        Be extra cautious and double check that dome is closed if it should be
        """
        while True:
            if not self.domeOpen and not self.domeConfirmedClosed:
                dome_info = self.hardware['dome'].getInfo()
                if dome_info['dome'] == 'closed':
                    # phew
                    self.domeConfirmedClosed = 1
                    self.log.info('dome confirmed closed')
                elif time.time() - self.timeOfLastCloseDomeCommand > 45.:
                    self.log.warn('dome not closed. Trying again...')
                    self.close_dome()
            await asyncio.sleep(10)

    async def observe(self, until_sun_alt=-15):
        """
        Observe until further notice.

        Parameters
        ----------
        until_sun_alt : float
            sun altitude at which to stop observing
        """
        self.log.info("observing")

        # start checking Schedule
        # normally, we'd do this when the pilot starts, but
        # the fake scheduler only has a few tasks in it, sorted
        # we leave it until observing starts so we don't run
        # out of jobs.
        self.running_tasks.append(
            asyncio.ensure_future(self.checkSchedule())
        )

        while True:

            # do nothing if paused
            if self.paused:
                await asyncio.sleep(5)
                continue

            # should we stop for the sun?
            now = Time.now()
            midnight = Time(nightStarting() + "T23:59:00")
            if now > midnight and sun_alt(now) > until_sun_alt:
                return

            # see if a new target has arrived and mark job appropriately
            if self.currentID != self.newID:
                if self.currentID is not None:
                    self.log.info("got new job from scheduler %s", self.newID)
                    # this will fail if obsStartTime not currently defined
                    try:
                        timeElapsed = time.time() - self.obsStartTime
                    except:
                        # in which case...
                        timeElapsed = 0
                    self.log.info('min time = {}, time elapsed = {}'.format(
                        self.currentMinTime, timeElapsed
                    ))
                    if timeElapsed > self.currentMinTime:
                        markJobCompleted(self.currentID)
                        self.log.info('job completed: {}'.format(self.currentID))
                    else:
                        markJobInterrupted(self.currentID)
                        self.log.info('job interrupted: {}'.format(self.currentID))
                else:
                    self.log.info("got job from scheduler %s", self.newID)

                # start new job
                if self.newID is None:
                    # park scope
                    execute_command('mnt park')
                    execute_command('exq clear')
                    execute_command('cam abort')
                    self.currentID = self.newID
                    self.currentPriority = None
                    self.currentMinTime = None
                else:
                    cmd = [os.path.join(SCRIPT_PATH, 'observe.py'),
                           str(self.newID), str(self.newMinTime)]
                    self.log.info('starting Job {}'.format(self.newID))
                    self.obsStartTime = time.time()
                    # start job, will cancel current one automatically
                    asyncio.ensure_future(
                        self.startScript('OBS', SimpleProtocol, cmd)
                    )
                    markJobRunning(self.newID)
                    self.currentID = self.newID
                    self.currentPriority = self.newPriority
                    self.currentMinTime = self.newMinTime

            else:  # we are doing the right job, so do nothing
                await asyncio.sleep(5)

    async def cancelRunningScript(self):
        """
        Cancel the currently running Python script.

        This does nothing if the script is already done.
        """
        if self.runningScriptTransport is not None:
            # check job is still running
            if self.runningScriptTransport.get_returncode() is None:
                self.log.info("killing {}".format(self.runningScriptProtocol.jobName))

                # if we were observing, mark as aborted and clear queue
                if self.runningScriptProtocol.jobName == 'OBS' and self.currentID is not None:
                    markJobAborted(self.currentID)
                    execute_command('exq clear')
                    execute_command('cam abort')
                self.runningScriptTransport.terminate()
                await self.runningScriptResult

    async def startScript(self, name, protocol, cmd):
        """
        Launch an external Python script.

        Parameters
        ----------
        name : str
            A name for this process. Prepended to output from process.
        protocol : `pilot_protocols.PilotJobProtocol`
            Protocol used to process output from Process
        cmd : list
            A list of the command to be executed with Python. The
            first element of the list is the Python script to execute,
            any additional elements are the arguments to the script.
        """
        # I don't think external jobs should run whilst paused
        if self.paused:
            self.log.warn("tried to start external script whilst paused")
            return 0, True

        # first, cancel any currently running script
        await self.cancelRunningScript()

        # future to store result in
        self.runningScriptResult = asyncio.Future()
        # fill the name, future and logName arguments of protocol(...)
        # using functools.partial
        factory = functools.partial(protocol, name, self.runningScriptResult,
                                    'pilot')
        loop = asyncio.get_event_loop()
        '''
        create the process coroutine which will return
        a 'transport' and 'protocol' when scheduled
        '''
        proc = loop.subprocess_exec(
            factory,
            sys.executable, '-u',  # sys.executable is Python, '-u' to flush stdout
            *cmd,
            stdin=None,
            stderr=None
        )
        # start the process and get transport and protocol for control of it
        self.runningScriptTransport, self.runningScriptProtocol = await proc
        # process started, await completion
        retcode = await self.runningScriptResult
        # done
        return retcode

    async def waitForNightsEnd(self, stopTime, sleepTime=1):
        """
        Function returns when night is done.

        This function simply keeps running until the stopTime is reached.
        The use of such a function is that it can be added to the list
        of tasks supplied to `~asyncio.BaseEventLoop.run_until_complete`
        and the loop will keep going until the stopTime is reached.

        Sleeps periodically to allow other jobs to be done.

        Parameters
        -----------
        stopTime : `~astropy.time.Time`
            the time to stop the Pilot
        sleepTime : float or int
            the time to sleep between checks against `stopTime`
        """
        while Time.now() < stopTime:
            status_str = Time.now().iso
            if self.paused:
                status_str += " (paused)"
            self.log.info(status_str)
            if self.paused:
                self.log.info(self.whypause)
            await asyncio.sleep(30)

        await self.shutdown()

        self.log.info("done")

    async def reallyReallyCloseDome(self, time_until_panic=10):
        """
        Close the dome, make sure it's closed and email if it won't

        Parameters
        ----------
        time_until_panic : float
            time in minutes to wait before emailing
        """
        start_time = time.time()
        self.close_dome()
        domeShut = False
        while not domeShut:
            elapsed_time = time.time() - start_time
            # if we've waited too long,  email
            if elapsed_time / 60. > time_until_panic:
                msg = "IMPORTANT: pilot cannot close dome. Take action immediately."
                send_email(message=msg)
            dome_info = self.hardware['dome'].getInfo()
            if dome_info['dome'] == 'closed':
                domeShut = True
            self.log.info('Waiting for dome to close')
            await asyncio.sleep(10)

    async def shutdown(self):
        """
        Perform a normal shutdown.

        Close any running jobs and exit
        """
        # first and most important.
        # NEVER STOP WITHOUT CLOSING THE DOME!
        # EMAIL IF DOME WON'T CLOSE
        await self.reallyReallyCloseDome()

        # if we have external subprocess running, stop it
        await self.cancelRunningScript()

        # close any running tasks
        for future in self.running_tasks:
            future.cancel()

    async def emergency_shutdown(self):
        """
        Stop what we're doing.

        Power off, shutdown daemons and exit Pilot
        """
        # park scope and power off
        cmd = [os.path.join(SCRIPT_PATH, 'power_off.py')]
        retcode, results = await self.startScript('EON', SimpleProtocol, cmd)
        if retcode != 0:
            self.log.warn('EON ended abnormally')

        # shutdown daemons
        cmd = [os.path.join(SCRIPT_PATH, 'shutdown_daemons.py')]
        retcode, results = await self.startScript('DAE', SimpleProtocol, cmd)
        if retcode != 0:
            self.log.warn('DAE ended abnormally')
        await self.shutdown()

    async def open_dome(self):
        self.log.warn('opening dome')
        execute_command('dome open')
        self.domeOpen = 1
        # make sure the dome starts reporting errors
        self.hardware['dome'].setMode('open')
        self.domeConfirmedClosed = 0
        while self.domeStatus() != 'open':
            await asyncio.sleep(10)

    def domeStatus(self):
        try:
            return self.hardware['dome'].getInfo()['dome']
        except:
            return 'err'

    def close_dome(self):
        self.log.warn('closing dome')
        execute_command('dome close')
        self.domeOpen = 0
        # make sure the dome starts reporting errors
        self.hardware['dome'].setMode(None)
        self.domeConfirmedClosed = 0
        self.timeOfLastCloseDomeCommand = time.time()

    def assignJobs(self):
        sn0 = dict(name='DAE', sunAlt=10,
                   cmd=[os.path.join(SCRIPT_PATH, 'start_daemons.py')],
                   protocol=SimpleProtocol)
        sn1 = dict(name='SN1', sunAlt=9,
                   cmd=[os.path.join(SCRIPT_PATH, 'start_of_night_1.py')],
                   protocol=SimpleProtocol)
        sn2 = dict(name='SN2', sunAlt=8,
                   cmd=[os.path.join(SCRIPT_PATH, 'start_of_night_2.py')],
                   protocol=SimpleProtocol)
        sn3 = dict(name='SN3', sunAlt=7,
                   cmd=[os.path.join(SCRIPT_PATH, 'start_of_night_3.py'), '3'],
                   protocol=SimpleProtocol)
        self.daytime_jobs = [sn0, sn1, sn2, sn3]

        sn4 = dict(name='FLATS', sunAlt=0,
                   cmd=[os.path.join(SCRIPT_PATH, 'takeFlats.py'), 'EVE'],
                   protocol=SimpleProtocol)
        sn5 = dict(name='FOC', sunAlt=-7,
                   cmd=[os.path.join(SCRIPT_PATH, 'autoFocus.py'), '20', 'G'],
                   protocol=SimpleProtocol)
        sn6 = dict(name='STD', sunAlt=-12,
                   cmd=[os.path.join(SCRIPT_PATH, 'takeStandards.py')],
                   protocol=SimpleProtocol)
        self.evening_jobs = [sn4, sn6]

        en0 = dict(name='FLATS', sunAlt=-7,
                   cmd=[os.path.join(SCRIPT_PATH, 'takeFlats.py'), 'MORN'],
                   protocol=SimpleProtocol)
        en1 = dict(name='POWOFF', sunAlt=0,
                   cmd=[os.path.join(SCRIPT_PATH, 'power_off.py')],
                   protocol=SimpleProtocol)
        en2 = dict(name='DAE', sunAlt=1,
                   cmd=[os.path.join(SCRIPT_PATH, 'shutdown_daemons.py')],
                   protocol=SimpleProtocol)
        self.morning_jobs = [en0, en1, en2]

if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.set_debug(False)
    pilot = Pilot(testing=True)
    pilot.assignJobs()

    # start the recurrent tasks
    pilot.running_tasks.extend([
        asyncio.ensure_future(pilot.nightMarshall()),
        asyncio.ensure_future(pilot.hardwareChecks()),
        asyncio.ensure_future(pilot.check_flags()),
        asyncio.ensure_future(pilot.doubleCheckDome())
    ])

    # keep the pilot runing until the end of the night
    stopSignal = pilot.waitForNightsEnd(Time.now() + 10*u.minute)

    try:
        loop.run_until_complete(stopSignal)
    except asyncio.CancelledError:
        print('Tasks cancelled')
    finally:
        print("Pilot Done")
        loop.close()
