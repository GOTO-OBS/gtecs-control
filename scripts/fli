#!/usr/bin/env python
"""
A script to provide control over fli interface daemons
"""

import os
import sys
import time
import readline
import Pyro4

from gtecs import misc
from gtecs import params
from gtecs import style
from gtecs import daemons


DAEMON_ID = os.path.basename(__file__)

DAEMON_IDS = []
for daemon_ID in params.DAEMONS:
    if daemon_ID in params.FLI_INTERFACES:
        DAEMON_IDS.append(daemon_ID)
DAEMON_IDS.sort()


def query(command, args, daemon_IDs):
    # Command functions
    if command in ['help', '?']:
        print_instructions()

    elif command == 'i':
        raise misc.InputError('Already in interactive mode')

    # Primary daemon control
    elif command == 'start':
        for daemon_ID in daemon_IDs:
            with misc.print_errors():
                reply = daemons.start_daemon(daemon_ID)
                print(reply)

    elif command == 'shutdown':
        for daemon_ID in daemon_IDs:
            with misc.print_errors():
                reply = daemons.shutdown_daemon(daemon_ID)
                print(reply)

    elif command == 'restart':
        for daemon_ID in daemon_IDs:
            with misc.print_errors():
                reply = daemons.restart_daemon(daemon_ID)
                print(reply)

    elif command == 'kill':
        for daemon_ID in daemon_IDs:
            with misc.print_errors():
                reply = daemons.kill_daemon(daemon_ID)
                print(reply)

    elif command == 'ping':
        for daemon_ID in daemon_IDs:
            with misc.print_errors():
                reply = daemons.ping_daemon(daemon_ID)
                print(reply)

    elif command in ['log', 'tail']:
        for daemon_ID in daemon_IDs:
            # parse arguments
            if 'stdout' in args:
                log_path = params.LOG_PATH + daemon_ID + '-stdout.log'
                args.remove('stdout')
            else:
                log_path = params.LOG_PATH + daemon_ID + '.log'
            tail_command = 'tail {} {}'.format(log_path, ' '.join(args))
            # send command
            misc.execute_command(tail_command)

    # Unrecognized function
    else:
        raise misc.InputError('Unrecognized command "{}"'.format(command))


def print_instructions():
    help_str = style.bold('Usage:') + ' fli [command]' + '\n' +\
    ' ' + style.undl('Interface commands') + ':' + '\n' +\
    '  fli ' + style.bold('start') + '             - start the interfaces' + '\n' +\
    '  fli ' + style.bold('shutdown') + '          - shutdown the interfaces' + '\n' +\
    '  fli ' + style.bold('restart') + '           - restart the interfaces' + '\n' +\
    '  fli ' + style.bold('kill') + '              - kill the interfaces (' + style.rtxt('emergency use') + ')' + '\n' +\
    '  fli ' + style.bold('ping') + '              - ping the interfaces' + '\n' +\
    '  fli ' + style.bold('log') + ' [stdout]' + '      - print daemon log (tail alias)' + '\n' +\
    ' ' + style.undl('Control commands') + ':' + '\n' +\
    '  fli ' + style.bold('i') + '                 - enter interactive mode' + '\n' +\
    '  fli ' + style.bold('q') + '/' + style.bold('exit') + '            - quit interactive mode' + '\n' +\
    '  fli ' + style.bold('?') + '/' + style.bold('help') + '            - print these instructions'
    print(help_str)


if __name__ == "__main__":
    if len(sys.argv) == 1:
        print_instructions()
    else:
        command, *args = sys.argv[1:]
        if command == 'i':
            while True:
                interactive_input = input('{}> '.format(DAEMON_ID)).split()
                if len(interactive_input) > 0:
                    command, *args = interactive_input
                    if command in ['q', 'exit']:
                        break
                    else:
                        with misc.print_errors():
                            query(command, args, DAEMON_IDS)
        else:
            with misc.print_errors():
                query(command, args, DAEMON_IDS)
