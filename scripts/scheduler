#!/usr/bin/env python
"""
A script to provide control over the scheduler daemon
"""

import os
import sys
import time
import readline
import Pyro4

from astropy.time import Time

from gtecs import misc
from gtecs import params
from gtecs import style
from gtecs import daemons


DAEMON_ID = os.path.basename(__file__)


def query(command, args, daemon_ID):
    # Command functions
    if command in ['help', '?']:
        print_instructions()

    elif command == 'i':
        raise misc.InputError('Already in interactive mode')

    # Primary daemon control
    elif command == 'start':
        reply = daemons.start_daemon(daemon_ID)
        print(reply)

    elif command == 'shutdown':
        reply = daemons.shutdown_daemon(daemon_ID)
        print(reply)

    elif command == 'restart':
        reply = daemons.restart_daemon(daemon_ID)
        print(reply)

    elif command == 'kill':
        reply = daemons.kill_daemon(daemon_ID)
        print(reply)

    elif command == 'ping':
        reply = daemons.ping_daemon(daemon_ID)
        print(reply)

    elif command in ['info', 'status']:
        # parse arguments
        if len(args) == 0:
            info_type = 'simple'
        elif len(args) == 1 and args[0] in ['v','V','-v','-V']:
            info_type = 'verbose'
        else:
            raise misc.InputError('Invalid arguments')
        # send command
        reply = daemons.daemon_function(daemon_ID, 'get_info', [Time.now()])
        # print response
        if not reply:
            raise ValueError('No info returned, check daemon')
        elif info_type == 'simple':
            print_info_s(reply)
        elif info_type == 'verbose':
            print_info(reply)

    elif command in ['log', 'tail']:
        # parse arguments
        if 'stdout' in args:
            log_path = params.LOG_PATH + daemon_ID + '-stdout.log'
            args.remove('stdout')
        else:
            log_path = params.LOG_PATH + daemon_ID + '.log'
        tail_command = 'tail {} {}'.format(log_path, ' '.join(args))
        # send command
        misc.execute_command(tail_command, handle_ctrlc=True)

    # Unrecognized function
    else:
        raise misc.InputError('Unrecognized command "{}"'.format(command))


def print_info(info):
    print('####### SCHEDULER INFO ########')
    print('NEXT POINTING:')
    if info['next_pointing'] is not None:
        new_id = info['next_pointing'].id
        new_ra = info['next_pointing'].ra
        new_dec = info['next_pointing'].dec
        new_priority = info['next_pointing'].priority
        new_tileprob = info['next_pointing'].tileprob
        new_too = info['next_pointing'].too
        new_maxsunalt = info['next_pointing'].maxsunalt
        new_minalt = info['next_pointing'].minalt
        new_mintime = info['next_pointing'].mintime
        new_maxmoon = info['next_pointing'].maxmoon
        new_minmoonsep = info['next_pointing'].minmoonsep
        new_start = info['next_pointing'].start
        new_stop = info['next_pointing'].stop
        new_current = info['next_pointing'].current
        new_survey = info['next_pointing'].survey

        print('ID:         {}'.format(new_id))
        print('RA:         {}'.format(new_ra))
        print('Dec:        {}'.format(new_dec))
        print('Priority:   {:.4f}'.format(new_priority))
        print('TileProb:   {}'.format(new_tileprob))
        print('ToO         {}'.format(new_too))
        print('MaxSunAlt:  {}'.format(new_maxsunalt))
        print('MinAlt:     {}'.format(new_minalt))
        print('MinTime:    {}'.format(new_mintime))
        print('MaxMoon:    {}'.format(new_maxmoon))
        print('MinMoonSep: {}'.format(new_minmoonsep))
        print('Start:      {}'.format(new_start))
        print('Stop:       {}'.format(new_stop))
        print('Current:    {}'.format(new_current))
        print('Survey :    {}'.format(new_survey))
    else:
        print('ID:        None')

    print('~~~~~~~')
    print('Timestamp: %s' %info['timestamp'])
    print('###########################')


def print_info_s(info):
    print('SCHEDULER:')
    if info['next_pointing'] is not None:
        new_id = info['next_pointing'].id
        new_priority = info['next_pointing'].priority_now
        new_mintime = info['next_pointing'].mintime
        print('  ID: %i (Priority %.3f, MinTime %.1fs)' %(new_id,new_priority,new_mintime))
    else:
        print('  ID: None (Priority: None, MinTime: None)')


def print_instructions():
    help_str = style.bold('Usage:') + ' scheduler [command]' + '\n' +\
    ' ' + style.undl('Interface commands') + ':' + '\n' +\
    '  scheduler ' + style.bold('start') + '             - start the daemon' + '\n' +\
    '  scheduler ' + style.bold('shutdown') + '          - shutdown the daemon' + '\n' +\
    '  scheduler ' + style.bold('restart') + '           - restart the daemon' + '\n' +\
    '  scheduler ' + style.bold('kill') + '              - kill the daemon (' + style.rtxt('emergency use') + ')' + '\n' +\
    '  scheduler ' + style.bold('ping') + '              - ping the daemon' + '\n' +\
    '  scheduler ' + style.bold('info') + '/' + style.bold('status') + ' [v]' + '   - report current status' + '\n' +\
    '  scheduler ' + style.bold('log') + ' [stdout]' + '      - print daemon log (tail alias)' + '\n' +\
    ' ' + style.undl('Control commands') + ':' + '\n' +\
    '  scheduler ' + style.bold('i') + '                 - enter interactive mode' + '\n' +\
    '  scheduler ' + style.bold('q') + '/' + style.bold('exit') + '            - quit interactive mode' + '\n' +\
    '  scheduler ' + style.bold('?') + '/' + style.bold('help') + '            - print these instructions'
    print(help_str)


if __name__ == "__main__":
    if len(sys.argv) == 1:
        print_instructions()
    else:
        command, *args = sys.argv[1:]
        if command == 'i':
            while True:
                interactive_input = input('{}> '.format(DAEMON_ID)).split()
                if len(interactive_input) > 0:
                    command, *args = interactive_input
                    if command in ['q', 'exit']:
                        break
                    else:
                        with misc.print_errors():
                            query(command, args, DAEMON_ID)
        else:
            with misc.print_errors():
                query(command, args, DAEMON_ID)
