#!/usr/bin/env python
"""
GOTO conditions monitor
This version is a stop-gap for testing prior to installation of the GOTO
Vaisala weather station.
"""

import os
import sys
import time
import signal
import json

import numpy as np

from astropy.time import Time

from gtecs import params
from gtecs import misc
from gtecs import conditions
from gtecs.astronomy import sun_alt
from gtecs.observing import check_dome_closed


def ThereCanOnlyBeOne():
    """Quit if this process is already running (dodgy kludge!)"""
    ps=os.popen('ps -fu '+os.environ['LOGNAME']+' | grep -v cron | grep -v emacs' ).read()
    if ps.count(sys.argv[0])>1:
        print(ps)
        sys.exit()


# set monitor parameters
save_logs = True # write log file

old_weather = {}
last_update_time = Time('1970-1-1')

last_successful_ping = Time('1970-1-1')

loop = 0

## set default values of flags
# 0=good, 1=bad, 2=error

flags = {'dark': 2,
         'rain': 2,
         'windspeed': 2,
         'humidity': 2,
         'temperature': 2,
         'link': 2,
         }

# catch ctrl-c
signal.signal(signal.SIGINT, misc.signal_handler)

# start monitoring
ThereCanOnlyBeOne()
while True:
    loop +=1
    time.sleep(params.WEATHER_INTERVAL)
    now = Time.now()

    # ~~~~~~~~~~~~~~
    # get the weather dict
    weather = conditions.get_weather()

    # check if the weather values are recently updated
    for source in weather:
        dt = weather[source]['dt']
        if dt >= params.WEATHER_TIMEOUT or dt == -999:
            weather[source] = dict.fromkeys(weather[source], -999)

    # ~~~~~~~~~~~~~~
    # set weather flags
    # at least two of the external sources and one of the internal sources
    #    need to be valid
    # note the extra check if the flag is already set to 1,
    #    in which case a different (safer) limit is used to prevent repeated
    #    opening/closing of the dome if conditions are hovering near a limit.

    # RAIN
    rain_array = np.array([weather[source]['rain']
                          for source in weather
                          if 'rain' in weather[source]])

    valid_rain_mask = rain_array != -999
    valid_rain = rain_array[valid_rain_mask]

    if len(valid_rain) < 2:
        flags['rain'] = 2
    elif np.all(valid_rain == False):
        flags['rain'] = 0
    else:
        flags['rain'] = 1


    # WINDSPEED
    windspeed_max = params.MAX_WINDSPEED
    windspeed_max_closed = windspeed_max * 0.9
    windspeed_array = np.array([weather[source]['windspeed']
                               for source in weather
                               if 'windspeed' in weather[source]])

    valid_windspeed_mask = windspeed_array != -999
    valid_windspeed = windspeed_array[valid_windspeed_mask]

    if len(valid_windspeed) < 2:
        flags['windspeed'] = 2
    elif (flags['windspeed'] != 1 and
          np.all(valid_windspeed < windspeed_max)):
        flags['windspeed'] = 0
    elif (flags['windspeed'] == 1 and
          np.all(valid_windspeed < windspeed_max_closed)):
        flags['windspeed'] = 0
    else:
        flags['windspeed'] = 1


    # HUMIDITY
    humidity_max = params.MAX_HUMIDITY
    humidity_max_closed = humidity_max * 0.9
    humidity_array = np.array([weather[source]['humidity']
                              for source in weather
                              if 'humidity' in weather[source]])

    valid_humidity_mask = humidity_array != -999
    valid_humidity = humidity_array[valid_humidity_mask]

    int_humidity_max = params.MAX_INTERNAL_HUMIDITY
    int_humidity_max_closed = int_humidity_max * 0.9
    int_humidity_array = np.array([weather[source]['int_humidity']
                                  for source in weather
                                  if 'int_humidity' in weather[source]])

    valid_int_humidity_mask = int_humidity_array != -999
    valid_int_humidity = int_humidity_array[valid_int_humidity_mask]

    if len(valid_humidity) < 2 or len(valid_int_humidity) < 1:
        flags['humidity'] = 2
    elif (flags['humidity'] != 1 and
          np.all(valid_humidity < humidity_max) and
          np.all(valid_int_humidity < int_humidity_max)):
        flags['humidity'] = 0
    elif (flags['humidity'] == 1 and
          np.all(valid_humidity < humidity_max_closed) and
          np.all(valid_int_humidity < int_humidity_max_closed)):
        flags['humidity'] = 0
    else:
        flags['humidity'] = 1


    # TEMPERATURE
    temp_min = params.MIN_TEMPERATURE
    temp_min_closed = temp_min + 1
    temp_max = params.MAX_TEMPERATURE
    temp_max_closed = temp_max - 1
    temp_array = np.array([weather[source]['temperature']
                          for source in weather
                          if 'temperature' in weather[source]])

    valid_temp_mask = temp_array != -999
    valid_temp = temp_array[valid_temp_mask]

    if len(valid_temp) < 2:
        flags['temperature'] = 2
    elif (flags['temperature'] != 1 and
          np.all(valid_temp > temp_min) and
          np.all(valid_temp < temp_max)):
        flags['temperature'] = 0
    elif (flags['temperature'] == 1 and
          np.all(valid_temp > temp_min_closed) and
          np.all(valid_temp < temp_max_closed)):
        flags['temperature'] = 0
    else:
        flags['temperature'] = 1


    # CHECK - if the data hasn't changed for a certain time
    if weather != old_weather:
        last_update_time = Time.now()
        old_weather = weather.copy()
    else:
        time_since_update = Time.now() - last_update_time
        if time_since_update.to('second').value > params.WEATHER_STATIC:
            flags['rain'] = 2
            flags['windspeed'] = 2
            flags['humidity'] = 2
            flags['temperature'] = 2

    # ~~~~~~~~~~~~~~
    # get the current sun alt to set the dark flag
    sunalt_now = sun_alt(Time.now())

    if sunalt_now < params.SUN_ELEVATION_LIMIT:
        flags['dark'] = 0
    else:
        flags['dark'] = 1

    # ~~~~~~~~~~~~~~
    # check the connectivity with Warwick to set the link flag
    ping_home = conditions.check_external_connection()
    if ping_home:
        last_successful_ping = Time.now()
    dt = Time.now() - last_successful_ping
    dt = dt.to('second').value

    link_interval_closed = params.WARWICK_CLOSED
    link_interval_open = params.WARWICK_OPEN

    try:
        dome_closed = check_dome_closed()
        if dome_closed and dt < link_interval_closed:
            flags['link'] = 0
        elif not dome_closed and dt < link_interval_open:
            flags['link'] = 0
        else:
            flags['link'] = 1
    except:
        flags['link'] = 2


    # ~~~~~~~~~~~~~~
    # now write all the values to the conditions flags file in JSON format
    data = {'update_time': str(now.iso)}
    data.update(flags)

    flags_file = params.CONFIG_PATH + 'conditions_flags'
    with open(flags_file, 'w') as f:
        json.dump(data, f)


    # ~~~~~~~~~~~~~~
    # print useful info, write to the conditions monitor log file if required

    log_line = '{:.0f} {} {}'.format(loop, now.iso, flags)
    print(log_line)

    if save_logs:
        log_folder = params.LOG_PATH
        date = str(now.iso).split()[0].replace('-','_')
        log_file = log_folder + '{}_conditions_monitor.log'.format(date)
        with open(log_file, 'a') as f:
            f.write(log_line)

    latestlog_file = params.CONFIG_PATH + 'conditions_monitor'
    with open(latestlog_file, 'w') as f:
        f.write(log_line)
