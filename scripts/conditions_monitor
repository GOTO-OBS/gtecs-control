#!/usr/bin/env python
# GOTO conditions monitor
# This version is a stop-gap for testing prior to installation of the GOTO
# Vaisala weather station.
# vsd @ING 27-Mar-2017

import time, math, ephem, string, os, subprocess, re, signal, smtplib, sys, urllib, calendar, json
import numpy as np

from astropy.time import Time
from gtecs.tecs_modules import params
from gtecs.tecs_modules import misc
from gtecs.tecs_modules import astronomy
from gtecs.tecs_modules import daemons

# function to trap ctrl-c and exit cleanly by closing open files
def signal_handler(signal, frame):
        print ('...ctrl+c detected - stopping the conditions monitor...')
        sys.exit(0)
signal.signal(signal.SIGINT, signal_handler)


def curl_data_from_url(url, outfile, encoding=None):
    '''Fetch data from a URL, store it in a file and return the contents'''

    curl_command = 'curl -s -m 10 -o {} {}'.format(outfile, url)
    os.popen(curl_command)
    if encoding:
        with open(outfile, 'r', encoding=encoding) as f:
            data = f.read()
    else:
        with open(outfile, 'r') as f:
            data = f.read()

    return data


def get_roomalert():
    '''Get internal dome temperature and humidity from GOTO RoomAlert system'''

    url = '10.2.6.5/getData.json'
    outfile = params.CONFIG_PATH + 'roomalert.json'
    indata = curl_data_from_url(url, outfile)
    data = json.loads(indata)

    internal_dict = {'int_temperature': -999,
                     'int_humidity': -999,
                     }

    try:
        dome_data = data['sensor'][0]
        temperature = float(dome_data['tc'])
        humidity = float(dome_data['h'])
        internal_dict['int_temperature'] = temperature
        internal_dict['int_humidity'] = humidity
    except:
        print('Error parsing RoomAlert page')

    return internal_dict


def get_ing_weather_html():
    '''Get the current weather from the ING weather page (JKT mast)'''

    url = 'http://catserver.ing.iac.es/weather/'
    outfile = params.CONFIG_PATH + 'weather.html'
    indata = curl_data_from_url(url, outfile, encoding='ISO-8859-1')

    delta_t = -999
    weather_dict = {'rain': -999,
                    'temperature': -999,
                    'pressure': -999,
                    'winddir': -999,
                    'windspeed': -999,
                    'windgust': -999,
                    'humidity': -999,
                    }

    try:
       for line in indata.split('\n'):
            columns = misc.remove_html_tags(line).replace(':',' ').split()
            if not columns:
                continue

            if columns[0] == 'Temperature':
                try:
                    weather_dict['temperature'] = float(columns[1])
                except:
                    print('Error parsing temperature:', columns[1])

            elif columns[0] == 'Pressure':
                try:
                    weather_dict['pressure'] = float(columns[1])
                except:
                    print('Error parsing pressure:', columns[1])

            elif columns[0] == 'Wind' and columns[1] == 'Speed':
                try:
                    weather_dict['windspeed'] = float(columns[2]) / 3.6 # km/h to m/s
                except:
                    print('Error parsing wind speed:', columns[2])

            elif columns[0] == 'Wind' and columns[1] == 'Direction':
                try:
                    weather_dict['winddir'] = str(columns[2])
                except:
                    print('Error parsing wind direction:', columns[2])

            elif columns[0] == 'Wind' and columns[1] == 'Gust':
                try:
                    weather_dict['windgust'] = float(columns[2]) / 3.6
                except:
                    print('Error parsing wind gust:', columns[2])

            elif columns[0] == 'Humidity':
                try:
                    weather_dict['humidity'] = float(columns[1])
                except:
                    print('Error parsing humidity:', columns[1])

            elif columns[0] == 'Rain':
                try:
                    if columns[1] == 'DRY':
                        weather_dict['rain'] = False
                    elif columns[1] == 'WET':
                        weather_dict['rain'] = True
                except:
                    print('Error parsing rain:', columns[1])

            elif len(columns) == 4 and columns[3] == 'UT':
                try:
                    update_date = columns[0].replace('/', '-')
                    update_time = '{}:{}'.format(columns[1],columns[2])
                    update_dt = '{} {}'.format(update_date, update_time)
                    delta = Time.now() - Time(update_dt)
                    delta_t = delta.value
                except:
                    print('Error parsing update time:', *columns)

    except:
        print('Error parsing weather page')

    return delta_t, weather_dict


def get_ing_weather_xml(weather_source):
    '''Get the current weather from the internal ING xml weather file'''

    if weather_source == 'wht':
        url = "http://whtmetsystem.ing.iac.es/WeatherXMLData/LocalData.xml"
    elif weather_source == 'int':
        url = "http://intmetsystem.ing.iac.es/WeatherXMLData/LocalData.xml"
    elif weather_source == 'jkt':
        url = "http://intmetsystem.ing.iac.es/WeatherXMLData/MainData.xml"

    outfile = params.CONFIG_PATH + 'weather.xml'
    indata = curl_data_from_url(url, outfile)

    delta_t = -999
    weather_dict = {'rain': -999,
                    'temperature': -999,
                    'pressure': -999,
                    'winddir': -999,
                    'windspeed': -999,
                    'windgust': -999,
                    'humidity': -999,
                    }

    try:
        for line in indata.split('\n'):
            columns = line.split()
            try:
                label = columns[1].split("\"")[1].split(".")[2]
                value = columns[2].split("\"")[1]
            except:
                continue

            if label == 'date':
                try:
                    update = float(value)
                    delta = Time.now() - Time(update)
                    delta_t = delta.value
                except:
                    print('Error parsing update time:', value)

            elif label == 'LocalMastAirTemp' or label == 'MainMastAirTemp':
                try:
                    weather_dict['temperature'] = float(value)
                except:
                    print('Error parsing temperature:', value)

            elif label == 'LocalMastPressure' or label == 'MainMastPressure':
                try:
                    weather_dict['pressure'] = float(value)
                except:
                    print('Error parsing pressure:', value)

            elif label == 'LocalMastWindSpeed' or label == 'MainMastWindSpeed':
                try:
                    weather_dict['windspeed'] = float(value) / 3.6
                except:
                    print('Error parsing wind speed:', value)

            elif label == 'LocalMastWindDirection' or label == 'MainMastWindDirection':
                try:
                    weather_dict['winddir'] = str(value)
                except:
                    print('Error parsing wind direction:', value)

            elif label == 'LocalMastGust' or label == 'MainMastGust':
                try:
                    weather_dict['windgust'] = float(value) / 3.6
                except:
                    print('Error parsing wind gust:', value)

            elif label == 'LocalMastHumidity' or label == 'MainMastHumidity':
                try:
                    weather_dict['humidity'] = float(value)
                except:
                    print('Error parsing humidity:', value)

            elif label == 'LocalMastWetness' or label == 'MainMastWetness':
                try:
                    if float(value) <= 0:
                        weather_dict['rain'] = False
                    elif float(value) >= 1:
                        weather_dict['rain'] = True
                except:
                    print('Error parsing rain:', value)

    except:
        print('Error parsing weather page')

    return delta_t, weather_dict


def check_external_connection():
    '''Check the connection between the GOTO dome and gotohead in Warwick'''
    try:
        url = 'ngtshead.warwick.ac.uk'
        ping_command = 'ping -c 3 {} | grep "ttl="'.format(url)
        link = os.popen(ping_command).read()
        if "ttl=" in link:
            return True
        else:
            return False
    except:
        return False


def check_dome_closed():
    '''Function to get the current dome status

    Returns True if the dome is closed or False if it is open.

    It will raise an error if one occurs, catch it higher up.
    '''
    dome_info = daemons.daemon_function('dome', 'get_info')
    return dome_info['dome'] == 'closed'


def ThereCanOnlyBeOne():
    '''Quit if this process is already running (dodgy kludge!)'''
    ps=os.popen('ps -fu '+os.environ['LOGNAME']+' | grep -v cron | grep -v emacs' ).read()
    if ps.count(sys.argv[0])>1:
        print(ps)
        sys.exit()


# set monitor parameters
log_file = 0 # write log file, 0 = yes, 1 = no

old_weather = {}
last_update_time = Time('1970-1-1')

last_successful_ping = Time('1970-1-1')

loop = 0

## set default values of flags
# 0=good, 1=bad, 2=error

flags = {'dark': 2,
         'rain': 2,
         'windspeed': 2,
         'humidity': 2,
         'temperature': 2,
         'link': 2,
         }


# start monitoring
ThereCanOnlyBeOne()
while True:
    loop +=1
    time.sleep(params.WEATHER_INTERVAL)
    now = Time.now()


    # ~~~~~~~~~~~~~~
    # check the altitude of the Sun for the dark flag
    sun_alt_now = astronomy.sun_alt(now)
    if sun_alt_now < params.SUN_ELEVATION_LIMIT:
        flags['dark'] = 0
    else:
        flags['dark'] = 1


    # ~~~~~~~~~~~~~~
    # fetch the weather from the external source
    if params.WEATHER_SOURCE == 'html':
        deltat, weather = get_ing_weather_html()
    else:
        deltat, weather = get_ing_weather_xml(params.WEATHER_SOURCE)
    weather_source_used = params.WEATHER_SOURCE

    # check for errors, if there were then use the backup source
    if deltat > params.WEATHER_TIMEOUT or -999 in weather.values():
        if params.BACKUP_WEATHER_SOURCE != 'html':
            deltat, weather = get_ing_weather_xml(params.BACKUP_WEATHER_SOURCE)
        else:
            deltat, weather = get_ing_weather_html()
        weather_source_used = params.BACKUP_WEATHER_SOURCE

    # fetch the internal conditions from the RoomAlert
    internal_dict = get_roomalert()
    weather.update(internal_dict)

    # set flags
    # note the extra check if the flag is already set to 1,
    # in which case a different (safer) limit is used to prevent repeated
    # opening/closing of the dome if conditions are hovering near a limit.

    # RAIN
    rain_now = weather['rain']

    if rain_now == -999:
        flags['rain'] = 2
    elif rain_now == False:
        flags['rain'] = 0
    else:
        flags['rain'] = 1

    # WINDSPEED
    windspeed_max = params.MAX_WINDSPEED
    windspeed_max_closed = windspeed_max * 0.9
    windspeed_now = weather['windspeed']

    if windspeed_now == -999:
        flags['windspeed'] = 2
    elif flags['windspeed'] != 1 and windspeed_now < windspeed_max:
        flags['windspeed'] = 0
    elif flags['windspeed'] == 1 and windspeed_now < windspeed_max_closed:
        flags['windspeed'] = 0
    else:
        flags['windspeed'] = 1

    # HUMIDITY
    humidity_max = params.MAX_HUMIDITY
    humidity_max_closed = humidity_max * 0.9
    humidity_now = weather['humidity']
    int_humidity_max = params.MAX_LOCAL_HUMIDITY
    int_humidity_max_closed = int_humidity_max * 0.9
    int_humidity_now = weather['int_humidity']

    if humidity_now == -999 or int_humidity_now == -999:
        flags['humidity'] = 2
    elif flags['humidity'] != 1 and humidity_now < humidity_max and int_humidity_now < int_humidity_max:
        flags['humidity'] = 0
    elif flags['humidity'] == 1 and humidity_now < humidity_max_closed and int_humidity_now < int_humidity_max_closed:
        flags['humidity'] = 0
    else:
        flags['humidity'] = 1

    # TEMPERATURE
    temp_min = params.MIN_TEMPERATURE
    temp_min_closed = temp_min + 1
    temp_max = params.MAX_TEMPERATURE
    temp_max_closed = temp_max - 1
    temp_now = weather['temperature']

    if temp_now == -999:
        flags['temperature'] = 2
    elif flags['temperature'] != 1 and temp_min < temp_now < temp_max:
        flags['temperature'] = 0
    elif flags['temperature'] == 1 and temp_min_closed < temp_now < temp_max_closed:
        flags['temperature'] = 0
    else:
        flags['temperature'] = 1

    # CHECK - if the fetch timed out
    if deltat == -999 or deltat >= params.WEATHER_TIMEOUT:
        flags['rain'] = 2
        flags['windspeed'] = 2
        flags['humidity'] = 2
        flags['temperature'] = 2

    # CHECK - if the data hasn't changed for a certain time
    if weather != old_weather:
        last_update_time = Time.now()
        old_weather = weather.copy()
    else:
        time_since_update = Time.now() - last_update_time
        if time_since_update.to('second').value > params.WEATHER_STATIC:
            flags['rain'] = 2
            flags['windspeed'] = 2
            flags['humidity'] = 2
            flags['temperature'] = 2


    # ~~~~~~~~~~~~~~
    # check the connectivity with Warwick to set the link flag
    ping_home = check_external_connection()
    if ping_home:
        last_successful_ping = Time.now()
    dt = Time.now() - last_successful_ping
    dt = dt.to('second').value

    link_interval_closed = params.WARWICK_CLOSED
    link_interval_open = params.WARWICK_OPEN

    try:
        dome_closed = check_dome_closed()
        if dome_closed and dt < link_interval_closed:
            flags['link'] = 0
        elif not dome_closed and dt < link_interval_open:
            flags['link'] = 0
        else:
            flags['link'] = 1
    except:
        flags['link'] = 2


    # ~~~~~~~~~~~~~~
    # now write all the values to the conditions flags file in JSON format
    data = {'update_time': str(now.iso)}
    data.update(flags)

    flags_file = params.CONFIG_PATH + 'conditions_flags'
    with open(flags_file, 'w') as f:
        json.dump(data, f)


    # ~~~~~~~~~~~~~~
    # print useful info, write to the conditions monitor log file if required

    if weather_source_used == params.BACKUP_WEATHER_SOURCE:
        backup = 'backup'
    else:
        backup = ''
    if weather_source_used == 'html':
        src_log = backup + 'htmlJKT'
    elif weather_source_used == 'jkt':
        src_log = backup + 'xmlJKT'
    elif weather_source_used == 'int':
        src_log = backup + 'xmlINT'
    elif weather_source_used == 'wht':
        src_log = backup + 'xmlWHT'

    log_line = '{:.0f} {} '.format(loop, now.iso)
    log_line += 'source={} source_dt={:.4f} '.format(src_log, deltat)
    log_line += 'sunalt={:.2f} dark_flag={:.0f} '.format(sun_alt_now, flags['dark'])
    log_line += 'rain_flag={:.0f} '.format(flags['rain'])
    log_line += 'winddir={} windspeed={:.2f} wind_flag={:.0f} '.format(weather['winddir'], weather['windspeed'], flags['windspeed'])
    log_line += 'ext_hum={:.1f}% int_hum={:.1f}% hum_flag={} '.format(weather['humidity'], weather['int_humidity'], flags['humidity'])
    log_line += 'ext_temp={:.1f}C int_temp={:.1f}C temp_flag={:.0f} '.format(weather['temperature'], weather['int_temperature'], flags['temperature'])
    log_line += 'link_dt={:.3f} link_flag={:.0f} \n'.format(dt, flags['link'])
    print(log_line)

    if log_file == 0:
        log_folder = params.LOG_PATH
        date = str(now.iso).split()[0].replace('-','_')
        log_file = log_folder + '{}_conditions_monitor.log'.format(date)
        with open(log_file, 'a') as f:
            f.write(log_line)

    latestlog_file = params.CONFIG_PATH + 'conditions_monitor'
    with open(latestlog_file, 'w') as f:
        f.write(log_line)
