#!/usr/bin/env python3
"""A script to provide control over the UT interface daemons."""

import json
import os
import sys

from gtecs.common import logging
from gtecs.common.system import execute_long_command
from gtecs.control import daemons
from gtecs.control import errors
from gtecs.control import params
from gtecs.control.style import errortxt


def get_args(interface_id):
    """Format the arguments to send to the interface script.

    See also `parse_args()` in ut_interface.py.
    """
    args = [interface_id]
    for ut in params.INTERFACES[interface_id]:
        args.append('--ut')

        # UT number
        args.append(ut)

        # OTA details
        if params.UT_DICT[ut]['OTA'] is not None:
            hw_str = json.dumps(params.UT_DICT[ut]['OTA'], separators=(',', ':'))
            hw_str = hw_str.replace('{', '\\{')
            hw_str = hw_str.replace('}', '\\}')
            hw_str = hw_str.replace('"', '\\"')
            args.append('ota={}'.format(hw_str))

        # Camera details
        if params.UT_DICT[ut]['CAMERA'] is not None:
            hw_str = json.dumps(params.UT_DICT[ut]['CAMERA'], separators=(',', ':'))
            hw_str = hw_str.replace('{', '\\{')
            hw_str = hw_str.replace('}', '\\}')
            hw_str = hw_str.replace('"', '\\"')
            args.append('cam={}'.format(hw_str))

        # Focuser details
        if params.UT_DICT[ut]['FOCUSER'] is not None:
            hw_str = json.dumps(params.UT_DICT[ut]['FOCUSER'], separators=(',', ':'))
            hw_str = hw_str.replace('{', '\\{')
            hw_str = hw_str.replace('}', '\\}')
            hw_str = hw_str.replace('"', '\\"')
            args.append('foc={}'.format(hw_str))

        # Filter wheel details
        if params.UT_DICT[ut]['FILTERWHEEL'] is not None:
            hw_str = json.dumps(params.UT_DICT[ut]['FILTERWHEEL'], separators=(',', ':'))
            hw_str = hw_str.replace('{', '\\{')
            hw_str = hw_str.replace('}', '\\}')
            hw_str = hw_str.replace('"', '\\"')
            args.append('filt={}'.format(hw_str))

    return args


def query(command, args):
    """Process a query."""
    # Command functions
    if command in ['help', '?']:
        print_instructions()

    elif command == 'i':
        raise errors.InputError('Already in interactive mode')

    # Primary daemon control
    elif command == 'start':
        for daemon_id in sorted(params.INTERFACES):
            try:
                reply = daemons.start_daemon(daemon_id, args=get_args(daemon_id))
                print(reply)
            except Exception as error:
                print(errortxt('"{}: {}"'.format(type(error).__name__, error)))

    elif command == 'shutdown':
        for daemon_id in sorted(params.INTERFACES):
            try:
                reply = daemons.shutdown_daemon(daemon_id)
                print(reply)
            except Exception as error:
                print(errortxt('"{}: {}"'.format(type(error).__name__, error)))

    elif command == 'restart':
        for daemon_id in sorted(params.INTERFACES):
            try:
                reply = daemons.restart_daemon(daemon_id, args=get_args(daemon_id))
            except Exception as error:
                print(errortxt('"{}: {}"'.format(type(error).__name__, error)))

    elif command == 'kill':
        for daemon_id in sorted(params.INTERFACES):
            try:
                reply = daemons.kill_daemon(daemon_id)
                print(reply)
            except Exception as error:
                print(errortxt('"{}: {}"'.format(type(error).__name__, error)))

    elif command in ['check', 'ping']:
        for daemon_id in sorted(params.INTERFACES):
            try:
                reply = daemons.check_daemon(daemon_id)
                print(reply)
            except Exception as error:
                print(errortxt('"{}: {}"'.format(type(error).__name__, error)))

    elif command in ['info', 'status']:
        # parse arguments
        if len(args) == 0:
            info_type = 'verbose'
            force = False
        elif len(args) == 1 and args[0] in ['f', 'F', '-f', '-F', '--force-update']:
            info_type = 'verbose'
            force = True
        elif len(args) == 1 and args[0] in ['r', 'R', '-r', '-R', '--raw']:
            info_type = 'raw'
            force = False
        elif (len(args) == 2 and
              ((args[0] in ['r', 'R', '-r', '-R', '--raw'] and
                args[1] in ['f', 'F', '-f', '-F', '--force-update']) or
               (args[1] in ['r', 'R', '-r', '-R', '--raw'] and
                args[0] in ['f', 'F', '-f', '-F', '--force-update']))):
            info_type = 'raw'
            force = True
        else:
            raise errors.InputError('Invalid arguments')
        # send command
        reply_list = []
        for daemon_id in sorted(params.INTERFACES):
            try:
                reply = daemons.daemon_function(daemon_id, 'get_info', args=[force])
                if not reply:
                    raise ValueError('No info returned, check daemon')
                reply_list.append(reply)
            except Exception as error:
                print(errortxt('"{}: {}"'.format(type(error).__name__, error)))
        # print response
        if info_type == 'verbose':
            for reply in reply_list:
                print_info(reply)
        elif info_type == 'raw':
            for reply in reply_list:
                print(reply)

    elif command in ['log', 'tail']:
        if 'stdout' in args:
            stdout = True
            args.remove('stdout')
        else:
            stdout = False
        for daemon_id in sorted(params.INTERFACES):
            # parse arguments
            if stdout:
                log_file = daemon_id + '-stdout.log'
            else:
                log_file = daemon_id + '.log'
            log_path = logging.get_log_path() / log_file
            tail_command = 'tail {} {}'.format(log_path, ' '.join(args))
            # send command
            execute_long_command(tail_command)

    # Unrecognized function
    else:
        raise errors.InputError('Unrecognized command "{}"'.format(command))


def print_info(info):
    """Print the full info dict."""
    print('INTERFACE {} ({}):'.format(info['daemon_id'], params.DAEMONS[info['daemon_id']]['HOST']))
    if len(info['ota_serials']) > 0:
        print('   OTAs:          ', end='\t')
        for ut in info['uts']:
            if ut in info['ota_serials']:
                print('{}: {: <16}'.format(ut, info['ota_serials'][ut]), end='  ')
            else:
                print('{}: {: <16}'.format(ut, '----'), end='  ')
        print('')
    if len(info['cam_serials']) > 0:
        print('   Cameras:       ', end='\t')
        for ut in info['uts']:
            if ut in info['cam_serials']:
                print('{}: {: <16}'.format(ut, info['cam_serials'][ut]), end='  ')
            else:
                print('{}: {: <16}'.format(ut, '----'), end='  ')
        print('')
    if len(info['foc_serials']) > 0:
        print('   Focusers:      ', end='\t')
        for ut in info['uts']:
            if ut in info['foc_serials']:
                print('{}: {: <16}'.format(ut, info['foc_serials'][ut]), end='  ')
            else:
                print('{}: {: <16}'.format(ut, '----'), end='  ')
        print('')
    if len(info['filt_serials']) > 0:
        print('   Filter Wheels: ', end='\t')
        for ut in info['uts']:
            if ut in info['filt_serials']:
                print('{}: {: <16}'.format(ut, info['filt_serials'][ut]), end='  ')
            else:
                print('{}: {: <16}'.format(ut, '----'), end='  ')
        print('')


def print_instructions():
    """Print instructions for using the daemon."""
    print('Usage: intf command [options]',
          'Daemon commands:',
          '  start                          start the interfaces',
          '  shutdown                       shutdown the interfaces',
          '  restart                        restart the interfaces',
          '  kill                           kill the interfaces',
          '  check/ping                     check the interfaces for errors',
          'Interface commands:',
          '  info/status [-r] [-f]          report current status [raw/force-update]',
          '  log [stdout]                   print daemon log (tail alias)',
          'Control commands:',
          '  i                              enter interactive mode',
          '  q/exit                         quit interactive mode',
          '  ?/help                         print these instructions',
          sep='\n')


if __name__ == '__main__':
    if len(sys.argv) == 1:
        # No command: print help and exit
        print_instructions()
        sys.exit()

    command, *args = sys.argv[1:]
    if command != 'i':
        query(command, args)
    else:
        # Interactive mode
        while True:
            try:
                interactive_input = input('{}> '.format(os.path.basename(__file__))).split()
            except EOFError:
                print()
                sys.exit()
            if len(interactive_input) > 0:
                command, *args = interactive_input
                if command in ['q', 'exit']:
                    sys.exit()
                try:
                    query(command, args)
                except Exception as error:
                    print(errortxt('"{}: {}"'.format(type(error).__name__, error)))
