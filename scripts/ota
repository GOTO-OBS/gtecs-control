#!/usr/bin/env python3
"""A script to provide control over the OTA daemon."""

import json
import os
import sys

from gtecs.common import logging
from gtecs.common.system import execute_long_command
from gtecs.control import daemons
from gtecs.control import misc
from gtecs.control import params
from gtecs.control.style import errortxt


def query(command, args, daemon_id):
    """Process a query."""
    # Command functions
    if command in ['help', '?']:
        print_instructions()

    elif command == 'i':
        raise ValueError('Already in interactive mode')

    # Primary daemon control
    elif command == 'start':
        host, port = daemons.get_daemon_host(daemon_id)
        pid = daemons.start_daemon(daemon_id)
        print(f'Daemon {daemon_id} started on {host}:{port} (PID {pid})')

    elif command == 'shutdown':
        host, port = daemons.get_daemon_host(daemon_id)
        daemons.shutdown_daemon(daemon_id)
        print(f'Daemon {daemon_id} shutdown on {host}:{port}')

    elif command == 'restart':
        host, port = daemons.get_daemon_host(daemon_id)
        pid = daemons.restart_daemon(daemon_id)
        print(f'Daemon {daemon_id} restarted on {host}:{port} (PID {pid})')

    elif command == 'kill':
        host, port = daemons.get_daemon_host(daemon_id)
        daemons.shutdown_daemon(daemon_id, kill=True)
        print(f'Daemon {daemon_id} killed on {host}:{port}')

    elif command in ['check', 'ping']:
        host, port = daemons.get_daemon_host(daemon_id)
        pid = daemons.check_daemon(daemon_id)
        print(f'Daemon {daemon_id} is running on {host}:{port} (PID {pid})')

    elif command in ['info', 'status']:
        if len(args) == 0:
            info_type = 'simple'
            force = False
        elif len(args) == 1 and args[0] in ['f', 'F', '-f', '-F', '--force-update']:
            info_type = 'simple'
            force = True
        elif len(args) == 1 and args[0] in ['v', 'V', '-v', '-V', '--verbose']:
            info_type = 'verbose'
            force = False
        elif len(args) == 1 and args[0] in ['r', 'R', '-r', '-R', '--raw']:
            info_type = 'raw'
            force = False
        elif (len(args) == 2 and
              ((args[0] in ['v', 'V', '-v', '-V', '--verbose'] and
                args[1] in ['f', 'F', '-f', '-F', '--force-update']) or
               (args[1] in ['v', 'V', '-v', '-V', '--verbose'] and
                args[0] in ['f', 'F', '-f', '-F', '--force-update']))):
            info_type = 'verbose'
            force = True
        elif (len(args) == 2 and
              ((args[0] in ['r', 'R', '-r', '-R', '--raw'] and
                args[1] in ['f', 'F', '-f', '-F', '--force-update']) or
               (args[1] in ['r', 'R', '-r', '-R', '--raw'] and
                args[0] in ['f', 'F', '-f', '-F', '--force-update']))):
            info_type = 'raw'
            force = True
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            info = daemon.get_info(force)
        if not info:
            raise ValueError('No info returned, check daemon')
        elif info_type == 'simple':
            print_info_s(info)
        elif info_type == 'verbose':
            print_info(info)
        elif info_type == 'raw':
            print(json.dumps(info, indent=2, default=repr))

    elif command in ['log', 'tail']:
        if 'stdout' in args:
            log_file = f'{daemon_id}-stdout.log'
            args.remove('stdout')
        else:
            log_file = f'{daemon_id}.log'
        log_path = logging.get_log_path() / log_file
        tail_command = 'tail {} {}'.format(log_path, ' '.join(args))
        execute_long_command(tail_command)

    # Daemon functions
    elif command == 'open':
        if len(args) == 0:
            uts = params.UTS_WITH_COVERS
        elif len(args) == 1:
            uts = misc.valid_ints(args[0].split(','), params.UTS_WITH_COVERS)
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            daemon.open_covers(uts)
        print('Mirror covers opening')

    elif command == 'close':
        if len(args) == 0:
            uts = params.UTS_WITH_COVERS
        elif len(args) == 1:
            uts = misc.valid_ints(args[0].split(','), params.UTS_WITH_COVERS)
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            daemon.close_covers(uts)
        print('Mirror covers closing')

    elif command == 'stop':
        if len(args) == 0:
            uts = params.UTS_WITH_COVERS
        elif len(args) == 1:
            uts = misc.valid_ints(args[0].split(','), params.UTS_WITH_COVERS)
        else:
            raise ValueError('Invalid arguments')
        daemons.check_daemon(daemon_id)
        with daemons.daemon_proxy(daemon_id) as daemon:
            daemon.stop_covers(uts)
        print('Mirror covers stopping')

    # Unrecognized function
    else:
        raise ValueError('Unrecognized command "{}"'.format(command))


def print_info(info):
    """Print the full info dict."""
    print('#### OTA INFO ####')
    for ut in info['uts']:
        if ut in info['uts_with_covers']:
            host, port = daemons.get_daemon_host(info[ut]['interface_id'])
            print('OTA {} ({}:{})'.format(ut, host, port))
        else:
            print('OTA {}                     '.format(ut))
        print('Serial number:  {}'.format(info[ut]['serial_number']))
        print('Hardware class: {}'.format(info[ut]['hw_class']))
        if ut in info['uts_with_covers']:
            print('Mirror cover:   {}'.format(info[ut]['position'].capitalize()))
        else:
            print('Mirror cover:   NA')
        print('~~~~~~~')
    print('Uptime: {:.1f}s'.format(info['uptime']))
    print('Timestamp: {}'.format(info['timestamp']))
    print('###########################')


def print_info_s(info):
    """Print the info dict in a compact way."""
    for ut in info['uts']:
        if ut in info['uts_with_covers']:
            host, port = daemons.get_daemon_host(info[ut]['interface_id'])
            print('OTA {} ({}:{})'.format(ut, host, port), end=' ')
        else:
            print('OTA {}                     '.format(ut), end=' ')
        if ut in info['uts_with_covers']:
            print('  Mirror cover: [{}]'.format(info[ut]['position'].capitalize()))
        else:
            print('  Mirror cover: [NA]')


def print_instructions():
    """Print instructions for using the daemon."""
    print('Usage: ota command [options]',
          'Daemon commands:',
          '  start                          start the daemon',
          '  shutdown                       shutdown the daemon',
          '  restart                        restart the daemon',
          '  kill                           kill the daemon',
          '  check/ping                     check the daemon for errors',
          'OTA commands:',
          '  open [uts]                     open mirror covers',
          '  close [uts]                    close mirror covers',
          '  stop [uts]                     stop mirror covers moving',
          '  info/status [-r|-v] [-f]       report current status [raw/verbose/force-update]',
          '  log [stdout]                   print daemon log (tail alias)',
          'Control commands:',
          '  i                              enter interactive mode',
          '  q/exit                         quit interactive mode',
          '  ?/help                         print these instructions',
          sep='\n')


if __name__ == '__main__':
    daemon_id = os.path.basename(__file__)
    if len(sys.argv) == 1:
        # No command: print help and exit
        print_instructions()
        sys.exit()

    command, *args = sys.argv[1:]
    if command != 'i':
        try:
            query(command, args, daemon_id)
        except Exception as error:
            print(errortxt('"{}: {}"'.format(type(error).__name__, error)))
    else:
        # Interactive mode
        while True:
            try:
                interactive_input = input(f'{daemon_id}> ').split()
            except EOFError:
                print()
                sys.exit()
            if len(interactive_input) > 0:
                command, *args = interactive_input
                if command in ['q', 'exit']:
                    sys.exit()
                try:
                    query(command, args, daemon_id)
                except Exception as error:
                    print(errortxt('"{}: {}"'.format(type(error).__name__, error)))
