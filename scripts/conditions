#!/usr/bin/env python
"""A script to provide control over the conditions daemon."""

import os
import sys

from gtecs import daemons
from gtecs import errors
from gtecs import misc
from gtecs import params
from gtecs import style


DAEMON_ID = os.path.basename(__file__)


def query(command, args, daemon_id):
    """Process a query."""
    # Command functions
    if command in ['help', '?']:
        print_instructions()

    elif command == 'i':
        raise errors.InputError('Already in interactive mode')

    # Primary daemon control
    elif command == 'start':
        reply = daemons.start_daemon(daemon_id)
        print(reply)

    elif command == 'shutdown':
        reply = daemons.shutdown_daemon(daemon_id)
        print(reply)

    elif command == 'restart':
        reply = daemons.restart_daemon(daemon_id)
        print(reply)

    elif command == 'kill':
        reply = daemons.kill_daemon(daemon_id)
        print(reply)

    elif command == 'ping':
        reply = daemons.ping_daemon(daemon_id)
        print(reply)

    elif command in ['info', 'status']:
        # send command
        reply = daemons.daemon_function(daemon_id, 'get_info')
        if not reply:
            raise ValueError('No info returned, check daemon')
        else:
            print_info(reply)

    elif command in ['log', 'tail']:
        # parse arguments
        if 'stdout' in args:
            log_path = params.LOG_PATH + daemon_id + '-stdout.log'
            args.remove('stdout')
        else:
            log_path = params.LOG_PATH + daemon_id + '.log'
        tail_command = 'tail {} {}'.format(log_path, ' '.join(args))
        # send command
        misc.execute_long_command(tail_command)

    # Unrecognized function
    else:
        raise errors.InputError('Unrecognized command "{}"'.format(command))


def print_info(info):
    """Print the full info dict."""
    if info['flags'] is None or info['weather'] is None:
        print('CONDITIONS:')
        print('  None yet, try again')
    else:
        flags = info['flags']
        weather = info['weather']
        print('FLAGS ({}):'.format(flags['update_time'][:-4]))
        del flags['update_time']
        for flag in sorted(flags):
            if flags[flag] == 0:
                status = style.gtxt('Good')
            elif flags[flag] == 1:
                status = style.rtxt('Bad')
            else:
                status = style.rtxt('ERROR')
            print('  {: >12} : {: <16} ({})'.format(flag, status, flags[flag]))
        print('WEATHER:')

        sunalt = info['sunalt']
        if sunalt < 0:
            sunalt_str = style.ytxt('{:>5.1f}'.format(sunalt))
            if sunalt < params.SUN_ELEVATION_LIMIT:
                sunalt_str = style.gtxt('{:>5.1f}'.format(sunalt))
        else:
            sunalt_str = style.rtxt('{:>5.1f}'.format(sunalt))
        print('  {: <10}   {} degrees'.format('sunalt', sunalt_str))

        # SuperWASP doesn't have a rain sensor
        weather['superwasp']['rain'] = 'NA'
        # SuperWASP wind readings aren't trustworthy
        weather['superwasp']['windspeed'] = 'NA'

        for source in ['goto', 'onemetre', 'superwasp']:
            temperature = weather[source]['temperature']
            humidity = weather[source]['humidity']
            windspeed = weather[source]['windspeed']
            rain = weather[source]['rain']
            dt = weather[source]['dt']

            if temperature == -999:
                temperature_str = style.rtxt(' ERR')
            elif (temperature < params.MAX_TEMPERATURE and
                  temperature > params.MIN_TEMPERATURE):
                temperature_str = style.ytxt('{:>4.1f}'.format(temperature))
                if (temperature < params.MAX_TEMPERATURE - 1 and
                        temperature > params.MIN_TEMPERATURE + 1):
                    temperature_str = style.gtxt('{:>4.1f}'.format(temperature))
            else:
                temperature_str = style.rtxt('{:>4.1f}'.format(temperature))

            if humidity == -999:
                humidity_str = style.rtxt('  ERR')
            elif (humidity < params.MAX_HUMIDITY):
                humidity_str = style.ytxt('{:>5.1f}'.format(humidity))
                if (humidity < params.MAX_HUMIDITY * 0.9):
                    humidity_str = style.gtxt('{:>5.1f}'.format(humidity))
            else:
                humidity_str = style.rtxt('{:>5.1f}'.format(humidity))

            if windspeed == -999:
                windspeed_str = style.rtxt('  ERR')
            elif windspeed == 'NA':
                windspeed_str = '  N/A'
            elif (windspeed < params.MAX_WINDSPEED):
                windspeed_str = style.ytxt('{:>5.1f}'.format(windspeed))
                if (windspeed < params.MAX_WINDSPEED * 0.9):
                    windspeed_str = style.gtxt('{:>5.1f}'.format(windspeed))
            else:
                windspeed_str = style.rtxt('{:>5.1f}'.format(windspeed))

            if rain == -999:
                rain_str = style.rtxt('  ERR')
            elif rain == 'NA':
                rain_str = '  N/A'
            elif rain:
                rain_str = style.rtxt(' True')
            else:
                rain_str = style.gtxt('False')

            if dt == -999:
                dt_str = style.rtxt('ERR')
            elif dt > params.WEATHER_TIMEOUT:
                dt_str = style.rtxt('{:>3.0f}'.format(dt))
            else:
                dt_str = style.gtxt('{:>3.0f}'.format(dt))

            print('  {: <10}'.format(source), end='\t')
            weather_str = '{}C  {}%  {} km/h  {}  dt={}'.format(temperature_str,
                                                                humidity_str,
                                                                windspeed_str,
                                                                rain_str,
                                                                dt_str)
            print(weather_str)

        # for source in ['dome', 'pier']:  # Disable dome sensor for dome 2
        for source in ['pier']:
            int_temperature = weather[source]['int_temperature']
            int_humidity = weather[source]['int_humidity']
            dt = weather[source]['dt']

            if int_temperature == -999:
                int_temperature_str = style.rtxt(' ERR')
            elif (int_temperature < params.MAX_INTERNAL_TEMPERATURE and
                  int_temperature > params.MIN_INTERNAL_TEMPERATURE):
                int_temperature_str = style.ytxt('{:>4.1f}'.format(int_temperature))
                if (int_temperature < params.MAX_INTERNAL_TEMPERATURE - 1 and
                        int_temperature > params.MIN_INTERNAL_TEMPERATURE + 1):
                    int_temperature_str = style.gtxt('{:>4.1f}'.format(int_temperature))
            else:
                int_temperature_str = style.rtxt('{:>4.1f}'.format(int_temperature))

            if int_humidity == -999:
                int_humidity_str = style.rtxt(' ERR')
            elif (int_humidity < params.MAX_INTERNAL_HUMIDITY):
                int_humidity_str = style.ytxt('{:>5.1f}'.format(int_humidity))
                if (int_humidity < params.MAX_INTERNAL_HUMIDITY * 0.9):
                    int_humidity_str = style.gtxt('{:>5.1f}'.format(int_humidity))
            else:
                int_humidity_str = style.rtxt('{:>5.1f}'.format(int_humidity))

            if dt == -999:
                dt_str = style.rtxt('ERR')
            elif dt > params.WEATHER_TIMEOUT:
                dt_str = style.rtxt('{:>3.0f}'.format(dt))
            else:
                dt_str = style.gtxt('{:>3.0f}'.format(dt))

            print('  {: <10}'.format(source + '_int'), end='\t')
            weather_str = '{}C  {}%                    dt={}'.format(int_temperature_str,
                                                                     int_humidity_str,
                                                                     dt_str)
            print(weather_str)

        ups_percents = info['ups_percent']
        ups_strings = []
        for ups_percent in ups_percents:
            if params.CRITICAL_UPSBATTERY < ups_percent < params.MIN_UPSBATTERY:
                ups_strings.append(style.ytxt('{:>5.1f}'.format(ups_percent)))
            elif ups_percent < params.CRITICAL_UPSBATTERY:
                ups_strings.append(style.rtxt('{:>5.1f}'.format(ups_percent)))
            else:
                ups_strings.append(style.gtxt('{:>5.1f}'.format(ups_percent)))
        print('  {: <10}   {}%'.format('ups', '%  '.join(ups_strings)))

        free_diskspace = info['free_diskspace']
        if free_diskspace < (params.MIN_DISKSPACE * 2):
            diskspace_str = style.ytxt('{:>5.1f}'.format(free_diskspace))
            if free_diskspace < params.MIN_DISKSPACE:
                diskspace_str = style.rtxt('{:>5.1f}'.format(free_diskspace))
        else:
            diskspace_str = style.gtxt('{:>5.1f}'.format(free_diskspace))
        print('  {: <10}   {}%'.format('diskspace', diskspace_str))


def print_instructions():
    """Print instructions for using the daemon."""
    print('Usage: conditions command [options]',
          'Daemon commands:',
          '  start                          start the daemon',
          '  shutdown                       shutdown the daemon',
          '  restart                        restart the daemon',
          '  kill                           kill the daemon',
          '  ping                           ping the daemon',
          'Conditions commands:',
          '  info/status [v]                report current status',
          '  log [stdout]                   print daemon log (tail alias)',
          'Control commands:',
          '  i                              enter interactive mode',
          '  q/exit                         quit interactive mode',
          '  ?/help                         print these instructions',
          sep='\n')


if __name__ == "__main__":
    if len(sys.argv) == 1:
        print_instructions()
    else:
        command, *args = sys.argv[1:]
        if command == 'i':
            while True:
                interactive_input = input('{}> '.format(DAEMON_ID)).split()
                if len(interactive_input) > 0:
                    command, *args = interactive_input
                    if command in ['q', 'exit']:
                        break
                    else:
                        with misc.print_errors():
                            query(command, args, DAEMON_ID)
        else:
            with misc.print_errors():
                query(command, args, DAEMON_ID)
