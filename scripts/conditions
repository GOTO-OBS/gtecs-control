#!/usr/bin/env python
"""
A script to provide control over the conditions daemon
"""

import os
import sys
import time
import readline
import Pyro4

from astropy.time import Time

from gtecs import misc
from gtecs import params
from gtecs import daemons
from gtecs.astronomy import sun_alt


def interactive():
    while True:
        i_in = input('{}> '.format(daemon_ID)).split()
        if len(i_in) > 0:
            command, *args = i_in
            if command == 'q' or command == 'exit':
                return
            else:
                with misc.print_errors():
                    query(command, args)


def query(command, args):
    # Command functions
    if command in ['help', '?']:
        print_instructions()

    elif command == 'i':
        raise misc.InputError('Already in interactive mode')

    # Primary daemon control
    elif command == 'start':
        reply = daemons.start_daemon(daemon_ID)
        print(reply)

    elif command == 'shutdown':
        reply = daemons.shutdown_daemon(daemon_ID)
        print(reply)

    elif command == 'restart':
        reply = daemons.restart_daemon(daemon_ID)
        print(reply)

    elif command == 'kill':
        reply = daemons.kill_daemon(daemon_ID)
        print(reply)

    elif command == 'ping':
        reply = daemons.ping_daemon(daemon_ID)
        print(reply)

    elif command == 'info':
        # send command
        reply = daemons.daemon_function(daemon_ID, 'get_info')
        if not reply:
            raise ValueError('No info returned, check daemon')
        else:
            print_info(reply)

    elif command in ['log', 'tail']:
        # parse arguments
        if 'stdout' in args:
            log_path = params.LOG_PATH + daemon_ID + '-stdout.log'
            args.remove('stdout')
        else:
            log_path = params.LOG_PATH + daemon_ID + '.log'
        tail_command = 'tail {} {}'.format(log_path, ' '.join(args))
        # send command
        misc.execute_command(tail_command)

    # Unrecognized function
    else:
        raise misc.InputError('Unrecognized command "{}"'.format(command))


def print_info(info):
    if info['flags'] is None or info['weather'] is None:
        print('CONDITIONS:')
        print('  None yet, try again')
    else:
        flags = info['flags']
        weather = info['weather']
        print('FLAGS ({}):'.format(flags['update_time'][:-4]))
        del flags['update_time']
        for flag in sorted(flags.keys()):
            if flags[flag] == 0:
                status = misc.gtxt('Good')
            elif flags[flag] == 1:
                status = misc.rtxt('Bad')
            else:
                status = misc.rtxt('ERROR')
            print('  {: >12} : {: <16} ({})'.format(flag, status, flags[flag]))
        print('WEATHER:')

        sunalt = sun_alt(Time.now())
        if sunalt < params.SUN_ELEVATION_LIMIT:
            sunalt_str = misc.gtxt('{:>5.1f}'.format(sunalt))
        else:
            sunalt_str = misc.rtxt('{:>5.1f}'.format(sunalt))
        print('  {: <10}   {} degrees'.format('sun_alt', sunalt_str))

        weather['superwasp']['rain'] = 'NA'
        for source in ['goto', 'onemetre', 'superwasp']:
            temperature = weather[source]['temperature']
            humidity = weather[source]['humidity']
            windspeed = weather[source]['windspeed']
            rain = weather[source]['rain']
            dt = weather[source]['dt']

            if temperature == -999:
                temperature_str = misc.rtxt(' ERR')
            elif (temperature < params.MAX_TEMPERATURE and
                  temperature > params.MIN_TEMPERATURE):
                temperature_str = misc.gtxt('{:>4.1f}'.format(temperature))
            else:
                temperature_str = misc.rtxt('{:>4.1f}'.format(temperature))

            if humidity == -999:
                humidity_str = misc.rtxt(' ERR')
            elif (humidity < params.MAX_HUMIDITY):
                humidity_str = misc.gtxt('{:>3.1f}'.format(humidity))
            else:
                humidity_str = misc.rtxt('{:>3.1f}'.format(humidity))

            if windspeed == -999:
                windspeed_str = misc.rtxt('  ERR')
            elif windspeed == 'NA':
                windspeed_str = '  N/A'
            elif (windspeed < params.MAX_WINDSPEED):
                windspeed_str = misc.gtxt('{:>5.1f}'.format(windspeed))
            else:
                windspeed_str = misc.rtxt('{:>5.1f}'.format(windspeed))

            if rain == -999:
                rain_str = misc.rtxt('  ERR')
            elif rain == 'NA':
                rain_str = '  N/A'
            elif rain:
                rain_str = misc.rtxt(' True')
            else:
                rain_str = misc.gtxt('False')

            if dt == -999:
                dt_str = misc.rtxt('ERR')
            elif dt > params.WEATHER_TIMEOUT:
                dt_str = misc.rtxt('{:>3.0f}'.format(dt))
            else:
                dt_str = misc.gtxt('{:>3.0f}'.format(dt))


            print('  {: <10}'.format(source), end='\t')
            weather_str = '{}C  {}%  {} km/s  {}  dt={}'.format(temperature_str,
                                                                humidity_str,
                                                                windspeed_str,
                                                                rain_str,
                                                                dt_str)
            print(weather_str)

        for source in ['dome', 'pier']:
            int_temperature = weather[source]['int_temperature']
            int_humidity = weather[source]['int_humidity']
            dt = weather[source]['dt']

            int_temperature_str = '{:>4.1f}'.format(int_temperature)

            if int_humidity == -999:
                int_humidity_str = misc.rtxt(' ERR')
            elif (int_humidity < params.MAX_INTERNAL_HUMIDITY):
                int_humidity_str = misc.gtxt('{:>3.1f}'.format(int_humidity))
            else:
                int_humidity_str = misc.rtxt('{:>3.1f}'.format(int_humidity))

            if dt == -999:
                dt_str = misc.rtxt('ERR')
            elif dt > params.WEATHER_TIMEOUT:
                dt_str = misc.rtxt('{:>3.0f}'.format(dt))
            else:
                dt_str = misc.gtxt('{:>3.0f}'.format(dt))

            print('  {: <10}'.format(source+'_int'), end='\t')
            weather_str = '{}C  {}%                     dt={}'.format(
                                                        int_temperature_str,
                                                        int_humidity_str,
                                                        dt_str)
            print(weather_str)


def print_instructions():
    help_str = misc.bold('Usage:') + ' conditions [command]' + '\n' +\
    ' ' + misc.undl('Interface commands') + ':' + '\n' +\
    '  conditions ' + misc.bold('start') + '             - start the daemon' + '\n' +\
    '  conditions ' + misc.bold('shutdown') + '          - shutdown the daemon' + '\n' +\
    '  conditions ' + misc.bold('restart') + '           - restart the daemon' + '\n' +\
    '  conditions ' + misc.bold('kill') + '              - kill the daemon (' + misc.rtxt('emergency use') + ')' + '\n' +\
    '  conditions ' + misc.bold('ping') + '              - ping the daemon' + '\n' +\
    '  conditions ' + misc.bold('info') + ' [v]' + '          - report current status' + '\n' +\
    '  conditions ' + misc.bold('log') + ' [stdout]' + '      - print daemon log (tail alias)' + '\n' +\
    ' ' + misc.undl('Control commands') + ':' + '\n' +\
    '  conditions ' + misc.bold('i') + '                 - enter interactive mode' + '\n' +\
    '  conditions ' + misc.bold('q') + '/' + misc.bold('exit') + '            - quit interactive mode' + '\n' +\
    '  conditions ' + misc.bold('?') + '/' + misc.bold('help') + '            - print these instructions'
    print(help_str)


if __name__ == "__main__":
    daemon_ID = os.path.basename(__file__)

    if len(sys.argv) == 1:
        print_instructions()
    else:
        command, *args = sys.argv[1:]
        if command == 'i':
            interactive()
        else:
            with misc.print_errors():
                query(command, args)
