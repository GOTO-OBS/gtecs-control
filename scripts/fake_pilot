#!/usr/bin/env python
# a fake pilot to test the scheduler
# heavily based on the pt5m pilot, including pointing files and html pages
# SL & MJD @ Sheffield, 2016

from __future__ import absolute_import
from __future__ import print_function

import os
import signal
import time

import george
import numpy as np
from scipy import stats

from astropy.time import Time, TimeDelta
from astropy.coordinates import SkyCoord
from astropy import units as u
import astroplan

from gtecs.tecs_modules import scheduler
from gtecs.tecs_modules import misc
from gtecs.tecs_modules import params
import gtecs.database as db

from six.moves import zip

# catch ctrl-c
signal.signal(signal.SIGINT, misc.signal_handler)

slewrate = 5 * u.degree/u.s
readouttime = 10*u.s

weather_on = 1

fake_dt = TimeDelta(60*u.s)  # 15*u.s)


def set_pointing_status(pointingID, status, session):
    '''Mark a pointing as completed, aborted etc'''
    if status not in ['aborted', 'completed', 'interrupted', 'running']:
        print('Illegal status:', status)
        return 1
    else:
        print('    Marking pointing', pointingID, 'as', status)
        try:
            pointing = db.get_pointing_by_id(session, pointingID)
            pointing.status = status
            session.commit()
            return 0
        except:
            session.rollback()
            print('Session error!!')
            return 1


class Weather(object):
    """class to simulate bad weather using Gaussian processes

    Args:
        start_time (astropy.time.Time): start of night (sunset)
        stop_time  (astropy.time.Time): end of night (sunset)
        timescale  (float): typical timescale of weather event (hours)
        frac_bad   (float): average fraction of night lost to bad weather"""
    def __init__(self, start_time, stop_time, timescale, frac_bad):
        self.start_time = start_time
        self.stop_time = stop_time
        self.kernel = george.kernels.Matern32Kernel(timescale)
        self.gp = george.GP(self.kernel)

        # evaluate guassian process on grid of hours between stop and start
        range = stop_time - start_time
        x = np.linspace(0, range.to(u.hour), 100)
        e = 0.0001*np.ones_like(x)
        # evaluate kernel of GP
        self.gp.compute(x, e)

        # now draw a sample from the GP to represent tonight's weather
        self.weather_graph = self.gp.sample(x)

        # GP follows Gaussian statistics with sigma=1.
        # for a given fraction of bad time, we can work out the amplitude
        # to use as a threshold for the GP using the percent point function
        # (the inverse of the cumulative distribution function
        # if weather_graph is below this threshold weather is bad!
        self.threshold = stats.norm.ppf(frac_bad)

    def is_bad(self, curr_time):
        if weather_on:
            x = (curr_time - self.start_time).to(u.hour)
            val, uncer = self.gp.predict(self.weather_graph, x)
            if val < self.threshold:
                return True
            else:
                return False
        else:
            return False


def get_night_times(date):
    """
    Calculate the start and stop times of a given date,
    defined as sunrise and sunset times for La Palma.
    """
    lapalma = astroplan.Observer.at_site('lapalma')
    # Time(date) gives start of date, add one day to get midnight that night
    midnight = Time(date) + TimeDelta(1*u.day)
    sunset = lapalma.sun_set_time(midnight, which="previous", horizon = -15*u.deg)
    sunrise = lapalma.sun_rise_time(midnight, which="next", horizon = -15*u.deg)
    return sunset, sunrise


def estimate_completion_time(newID, currentID, session):
    """
    Extimate the exposure time for a new pointing, based on the combined
    exposure times in all exposures and the time to move into position.
    """
    total_exptime = 0*u.s
    new_pointing = db.get_pointing_by_id(session, newID)
    for exp in new_pointing.exposure_sets:
        total_exptime += ((exp.expTime*u.s + readouttime) * exp.numexp)

    if currentID is not None:
        current_pointing = db.get_pointing_by_id(session, currentID)
        current_position = SkyCoord(current_pointing.ra,
                                    current_pointing.decl,
                                    unit=u.deg, frame='icrs')
        new_position = SkyCoord(new_pointing.ra,
                                new_pointing.decl,
                                unit=u.deg, frame='icrs')
        slew_distance = current_position.separation(new_position)
        slew_time = slew_distance/slewrate
    else:
        slew_time = 0*u.s
    return slew_time + total_exptime


class DummyPilot(object):
    """
    The dummy pilot simply checks to see if a more important pointing
    is available from the scheduler, or if it has finished the pointing
    it is supposed to be currently doing
    """

    def __init__(self):
        self.start_time = Time.now()

        self.currentID = None
        self.currentPriority = None
        self.currentMinTime = None
        self.current_start_time = None
        self.current_duration = None

        self.completed_pointings = []
        self.completed_times = []
        self.interrupted_pointings = []
        self.aborted_pointings = []

        self.dome_status = 0  # 1 = open, 0 = shut
        self.pilot_status = None

    def pause_observing(self, session):
        self.dome_status = 0
        self.pilot_status = 'Dome Closed'
        if self.currentID is not None:
            print('Aborting ID= %i due to bad weather' % self.currentID)
            self.aborted_pointings.append(self.currentID)
            set_pointing_status(self.currentID, 'aborted', session)
            self.currentID = None
            self.current_duration = None
            self.current_position = None

    def resume_observing(self):
        self.dome_status = 1
        self.pilot_status = 'Dome Open'

    def check_weather(self, weather, now, session):
        bad_weather = weather.is_bad(now)
        if bad_weather and self.dome_status:
            self.pause_observing(session)
        if not bad_weather and not self.dome_status:
            self.resume_observing()

    def log_state(self, now, session):
        '''Write the current state of the pilot to a log file'''
        state = 'unknown'
        if self.pilot_status == 'Suspended':
            state = 'manual'
        elif self.dome_status == 0:
            state = 'closed'
        elif self.currentID is not None:
            current_pointing = db.get_pointing_by_id(session, self.currentID)
            self.currentName = current_pointing.objectName
            self.currentRa   = current_pointing.ra
            self.currentDec  = current_pointing.decl
            current_tileID   = current_pointing.eventTileID
            current_tile = session.query(db.EventTile).filter(db.EventTile.tileID == current_tileID).one_or_none()
            self.currentProbability = current_tile.probability
            state = ('OBS: ID%i'    %self.currentID
                    +' (%s;'        %self.currentName
                    +' prob: %.8f;' %self.currentProbability
                    +' ra: %.4f;'   %self.currentRa
                    +' dec: %.4f;'  %self.currentDec
                    +' p: %.11f)'   %self.currentPriority)
        else:
            state = 'idle'
        fname = os.path.join(params.CONFIG_PATH, 'state_log.txt')
        with open(fname, 'a') as f:
            f.write('%s %s\n' % (now. iso, state))

    def review_target_situation(self, now, write_html, session):
        '''Check queue for a new target and, if necessary, go to it'''

        # check if current pointing is finished
        if self.currentID is not None:
            time_elapsed = (now - self.current_start_time).to(u.s)
            if time_elapsed > self.current_duration:
                self.currentPriority += 100
                set_pointing_status(self.currentID, 'completed', session)
                self.completed_pointings.append(self.currentID)
                self.completed_times.append(now)
            print('  current : ID', self.currentID)#, self.currentPriority)
        else:
            print('  current :', None)

        # find new highest priority from the scheduler
        newID, newPriority, newMinTime = scheduler.check_queue(now, write_html)
        if newID is not None:
            print('  queue   : ID', newID)#, newPriority)
        else:
            print('  queue   :', None)

        # what next
        if newID != self.currentID and newID not in self.completed_pointings:
            if self.currentID is not None:
                # we're already doing something,
                # mark as finished or interrupted
                try:
                    time_elapsed = (now - self.current_start_time).to(u.s)
                except:
                    time_elapsed = 0.
                if self.currentID not in self.completed_pointings:
                    if time_elapsed > self.currentMinTime:
                        set_pointing_status(self.currentID, 'completed', session)
                        self.completed_pointings.append(self.currentID)
                        self.completed_times.append(now)
                    else:
                        set_pointing_status(self.currentID, 'interrupted', session)
                        self.interrupted_pointings.append(self.currentID)

            if newID is not None:
                print('    -- STARTING NEW POINTING')
                self.currentID = newID
                self.currentPriority = newPriority
                self.currentMinTime = newMinTime
                self.current_duration = estimate_completion_time(newID, self.currentID, session)
                self.current_start_time = now
                set_pointing_status(self.currentID, 'running', session)
            else:
                print('    -- PARKING SCOPE')
                self.currentID = None

def run(date, sleep_time, write_html):

    pilot = DummyPilot()
    session = db.load_session()

    # weather has typical timescale = 1h and we lose 10% of time to bad weather
    sunset, sunrise = get_night_times(date)
    weather = Weather(sunset, sunrise, 1.0, 0.1)

    # loop until night is over
    print('Starting loop...')
    now = sunset
    ts = time.time()
    while now < sunrise:
        try:
            tprev = ts
            ts = time.time()
            now.format = 'iso'
            now.precision = 0
            print('Loop:', now, '  ---  dt:%.3fs' %(ts-tprev))
            pilot.check_weather(weather, now, session)
            if pilot.dome_status:  # open
                pilot.review_target_situation(now, bool(write_html), session)
            else:
                print('  dome closed')
            pilot.log_state(now, session)
            # increment by scheduler loop timestep
            now += fake_dt
            time.sleep(float(sleep_time))
        session.close()

    except Exception as e:
        print(e)
        session.close()

    print('Listing completed pointings and time done')
    for pointingID, timedone in zip(pilot.completed_pointings, pilot.completed_times):
        print(pointingID, timedone)

    print('Listing pointings aborted due to bad weather')
    for pointingID in pilot.aborted_pointings:
        print(pointingID)

    print('Listing pointings interrupted by other pointings')
    for pointingID in pilot.interrupted_pointings:
        print(pointingID)

if __name__ == "__main__":
    usage = """python fake_pilot.py date sleep_time write_html"""
    import argparse
    parser = argparse.ArgumentParser(description="run fake pilot for a night",
                                     usage=usage)
    parser.add_argument('date', help="night starting date to simulate")
    parser.add_argument('sleep_time', help="time to sleep each period")
    parser.add_argument('write_html', help="write html webpages?", type=int)
    args = parser.parse_args()

    run(args.date, args.sleep_time, args.write_html)
